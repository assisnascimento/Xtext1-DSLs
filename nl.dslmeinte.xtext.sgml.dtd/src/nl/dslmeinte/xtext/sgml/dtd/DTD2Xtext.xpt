«IMPORT dtdModel»

«EXTENSION org::eclipse::xtend::util::stdlib::io»
«EXTENSION nl::dslmeinte::xtend::util::emfExtensions»
«EXTENSION nl::dslmeinte::xtext::dtd::util::dtdExtensions»
«EXTENSION nl::dslmeinte::xtext::sgml::dtd::grammarHelper»


«DEFINE main(String fqLanguageName, String shortLanguageName, String nsURI) FOR DocumentTypeDefinition -»
// generated by DTD2Xtext.xpt
grammar «fqLanguageName» with nl.dslmeinte.xtext.sgml.base.Base hidden()

«EXPAND additionalMetamodelsContent»

generate «shortLanguageName» «nsURI»

«EXPAND sgmlDocumentRuleOverride»

«EXPAND element FOREACH definitions.typeSelect(Element)»

«EXPAND attributeRule FOREACH definitions.typeSelect(Element).attributes()»

«EXPAND additionalGrammarContent»

«ENDDEFINE»

«DEFINE main(String fqLanguageName, String nsURI) FOR DocumentTypeDefinition -»
«EXPAND main(fqLanguageName, fileNameWithoutExtension().toLowerCase(), nsURI)»
«ENDDEFINE»

«DEFINE additionalMetamodelsContent FOR DocumentTypeDefinition»
«ENDDEFINE»

«DEFINE additionalGrammarContent FOR DocumentTypeDefinition»
«ENDDEFINE»

«DEFINE element FOR Element»
«name» hidden(SGML_COMMENTS«IF !canHaveFollowingContent()», WHITESPACE«ENDIF»):
	«name»_tagOpen=«name»_tagOpen
	«EXPAND expression FOR content»
	«IF isCloseTagOptional()»(«ENDIF»«name»_tagClose=«name»_tagClose«IF isCloseTagOptional()»)?«ENDIF»
	;

«name»_tagOpen hidden(): «IF attributesCanBeEmpty()»{«name»_tagOpen} «ENDIF»'<' '«name»' «IF attributes().size > 0»(«FOREACH attributes() AS attrib SEPARATOR ' & '»«IF attrib.isOptional()»(«ENDIF»WHITESPACE «attrib.name»=«name»_«attrib.name»_attribute«IF attrib.isOptional()»)?«ENDIF»«ENDFOREACH»)«ENDIF» '>';
«name»_tagClose hidden(): {«name»_tagClose} '<' '/' '«name»' '>';
«ENDDEFINE»

«DEFINE attributeRule FOR Attribute»
«((AttributeList) eContainer).element.name»_«name»_attribute hidden(WHITESPACE): {«((AttributeList) eContainer).element.name»_«name»_attribute}«IF isOptional()»(«ENDIF»'«name»' '=' «name»=QuotedString«IF isOptional()»)?«ENDIF»;
«ENDDEFINE»

«DEFINE sgmlDocumentRuleOverride FOR DocumentTypeDefinition»
// override from Base to include root (of right type):
SgmlDocument hidden(WHITESPACE, SGML_COMMENTS):
		docType=DocumentType
		root=«definitions.typeSelect(Element).first().name»
	;

DocumentType hidden(WHITESPACE):
	'<' '!DOCTYPE' rootName=IDENTIFIER ('PUBLIC' | 'SYSTEM') header1=QuotedString header2=QuotedString? HEADER_COMMENTS*
		('[' ( entities+=Entity | SGML_COMMENTS )* ']')? '>'	
	;
«ENDDEFINE»


«REM»generation for Expression content«ENDREM»

«DEFINE expression FOR Expression»
«( "no DEFINE block for sub type " + metaType.name + " of " + Expression.metaType.name ).error()»
«ENDDEFINE»

«DEFINE expression FOR Alternatives»( «EXPAND expression FOREACH alternatives SEPARATOR ' | '» )«ENDDEFINE»

«DEFINE expression FOR Concatenation»«EXPAND expression FOREACH members SEPARATOR ' '»«ENDDEFINE»

«DEFINE expression FOR Cardinality»(«EXPAND expression FOR nestedExpr»)«cardinality.syntax()»«ENDDEFINE»

«DEFINE expression FOR EmptyContent»«ENDDEFINE»

«DEFINE expression FOR PCData»contents+=_PCDATA«ENDDEFINE»

«DEFINE expression FOR ElementReference»contents+=«element.name»«ENDDEFINE»

