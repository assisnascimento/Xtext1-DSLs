/*
* generated by Xtext
*/
package nl.dslmeinte.xtext.examples.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IEObjectConsumer;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import nl.dslmeinte.xtext.examples.services.DynamicScreenDslGrammarAccess;

import com.google.inject.Inject;

@SuppressWarnings("all")
public class DynamicScreenDslParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private DynamicScreenDslGrammarAccess grammarAccess;
	
	@Override
	protected AbstractToken getRootToken(IEObjectConsumer inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IEObjectConsumer inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DynamicScreen_Group(this, this, 0, inst);
			case 1: return new Label_Group(this, this, 1, inst);
			case 2: return new PathTail_Group(this, this, 2, inst);
			case 3: return new Declaration_Alternatives(this, this, 3, inst);
			case 4: return new ExternalVariable_Group(this, this, 4, inst);
			case 5: return new EnumList_Group(this, this, 5, inst);
			case 6: return new DataStore_Group(this, this, 6, inst);
			case 7: return new GroupElement_Alternatives(this, this, 7, inst);
			case 8: return new Field_Group(this, this, 8, inst);
			case 9: return new FieldGroup_Group(this, this, 9, inst);
			case 10: return new Attribute_Alternatives(this, this, 10, inst);
			case 11: return new EnumFieldAttribute_Alternatives(this, this, 11, inst);
			case 12: return new NormalAttribute_Group(this, this, 12, inst);
			case 13: return new AttributeClassExpression_Group(this, this, 13, inst);
			case 14: return new RestrictionAttribute_Group(this, this, 14, inst);
			case 15: return new RestrictionGroupAttribute_Group(this, this, 15, inst);
			case 16: return new RestrictionRule_Group(this, this, 16, inst);
			case 17: return new ReferenceTarget_Alternatives(this, this, 17, inst);
			case 18: return new Reference_RefAssignment(this, this, 18, inst);
			case 19: return new DummyForExternalVariable_Alternatives(this, this, 19, inst);
			case 20: return new BExpression_BOrExpressionParserRuleCall(this, this, 20, inst);
			case 21: return new BOrExpression_Group(this, this, 21, inst);
			case 22: return new BAndExpression_Group(this, this, 22, inst);
			case 23: return new NegationExpression_Alternatives(this, this, 23, inst);
			case 24: return new TerminalBExpression_Alternatives(this, this, 24, inst);
			case 25: return new AtomicReferringBExpression_Alternatives(this, this, 25, inst);
			case 26: return new BComparison_Group(this, this, 26, inst);
			case 27: return new EnumComparison_Alternatives(this, this, 27, inst);
			case 28: return new SingleEnumComparison_Group(this, this, 28, inst);
			case 29: return new MultiEnumComparison_Group(this, this, 29, inst);
			case 30: return new StringValueComparison_Group(this, this, 30, inst);
			case 31: return new PresenceCheck_Group(this, this, 31, inst);
			case 32: return new EnumLiteralsCollection_Alternatives(this, this, 32, inst);
			case 33: return new DirectEnumLiteralsCollection_Group(this, this, 33, inst);
			case 34: return new EnumListReference_RefAssignment(this, this, 34, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule DynamicScreen ****************
 *
 * / *
 *  * An instance of this DSL describes a screen with a lot of custom
 *  * dynamism (and structure) on it. The dynamism supported in the
 *  * language are:
 *  * 
 *  *  - fields are visible, mandatory (required), readonly or not
 *  *      depending on the values of other fields
 *  *  - selection list (of enums) are restricted depending on the
 *  *      values of other fields
 *  *
 *  * Aspects and features still TODO (roughly in order of priority):
 *  *
 *  *  1) add paths relative to data stores for non-enum selection lists
 *  *  2) short hand for commonly used boolean expressions
 *  *  3) sample population of fields (especially useful for data stores @1)
 *  * // *
 *  * +-----------------------------+
 *  * | Infrastructure and generics |
 *  * +-----------------------------+
 *  * /DynamicScreen:
 * 	"dynamic-screen" label=Label "data-import" "=" importURI=STRING "view-class" "=" viewClass=[data::Entity]
 * 	declarations+=Declaration* groups+=FieldGroup+;
 *
 **/

// "dynamic-screen" label=Label "data-import" "=" importURI=STRING "view-class" "=" viewClass=[data::Entity]
// declarations+=Declaration* groups+=FieldGroup+
protected class DynamicScreen_Group extends GroupToken {
	
	public DynamicScreen_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDynamicScreenAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DynamicScreen_GroupsAssignment_9(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDynamicScreenRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "dynamic-screen"
protected class DynamicScreen_DynamicScreenKeyword_0 extends KeywordToken  {
	
	public DynamicScreen_DynamicScreenKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDynamicScreenAccess().getDynamicScreenKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// label=Label
protected class DynamicScreen_LabelAssignment_1 extends AssignmentToken  {
	
	public DynamicScreen_LabelAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDynamicScreenAccess().getLabelAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Label_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("label",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("label");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLabelRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getDynamicScreenAccess().getLabelLabelParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new DynamicScreen_DynamicScreenKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "data-import"
protected class DynamicScreen_DataImportKeyword_2 extends KeywordToken  {
	
	public DynamicScreen_DataImportKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDynamicScreenAccess().getDataImportKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DynamicScreen_LabelAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "="
protected class DynamicScreen_EqualsSignKeyword_3 extends KeywordToken  {
	
	public DynamicScreen_EqualsSignKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDynamicScreenAccess().getEqualsSignKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DynamicScreen_DataImportKeyword_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// importURI=STRING
protected class DynamicScreen_ImportURIAssignment_4 extends AssignmentToken  {
	
	public DynamicScreen_ImportURIAssignment_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDynamicScreenAccess().getImportURIAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DynamicScreen_EqualsSignKeyword_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("importURI",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("importURI");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getDynamicScreenAccess().getImportURISTRINGTerminalRuleCall_4_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getDynamicScreenAccess().getImportURISTRINGTerminalRuleCall_4_0();
			return obj;
		}
		return null;
	}

}

// "view-class"
protected class DynamicScreen_ViewClassKeyword_5 extends KeywordToken  {
	
	public DynamicScreen_ViewClassKeyword_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDynamicScreenAccess().getViewClassKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DynamicScreen_ImportURIAssignment_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "="
protected class DynamicScreen_EqualsSignKeyword_6 extends KeywordToken  {
	
	public DynamicScreen_EqualsSignKeyword_6(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDynamicScreenAccess().getEqualsSignKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DynamicScreen_ViewClassKeyword_5(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// viewClass=[data::Entity]
protected class DynamicScreen_ViewClassAssignment_7 extends AssignmentToken  {
	
	public DynamicScreen_ViewClassAssignment_7(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDynamicScreenAccess().getViewClassAssignment_7();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DynamicScreen_EqualsSignKeyword_6(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("viewClass",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("viewClass");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDynamicScreenAccess().getViewClassEntityCrossReference_7_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getDynamicScreenAccess().getViewClassEntityCrossReference_7_0(); 
				return obj;
			}
		}
		return null;
	}

}

// declarations+=Declaration*
protected class DynamicScreen_DeclarationsAssignment_8 extends AssignmentToken  {
	
	public DynamicScreen_DeclarationsAssignment_8(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDynamicScreenAccess().getDeclarationsAssignment_8();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Declaration_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("declarations",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("declarations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getDynamicScreenAccess().getDeclarationsDeclarationParserRuleCall_8_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new DynamicScreen_DeclarationsAssignment_8(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new DynamicScreen_ViewClassAssignment_7(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// groups+=FieldGroup+
protected class DynamicScreen_GroupsAssignment_9 extends AssignmentToken  {
	
	public DynamicScreen_GroupsAssignment_9(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDynamicScreenAccess().getGroupsAssignment_9();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FieldGroup_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("groups",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("groups");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFieldGroupRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getDynamicScreenAccess().getGroupsFieldGroupParserRuleCall_9_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new DynamicScreen_GroupsAssignment_9(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new DynamicScreen_DeclarationsAssignment_8(lastRuleCallOrigin, next, actIndex, consumed);
			case 2: return new DynamicScreen_ViewClassAssignment_7(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule DynamicScreen ****************/


/************ begin Rule Label ****************
 *
 * Label:
 * 	en=STRING ("[nl:" nl=STRING "]")?;
 *
 **/

// en=STRING ("[nl:" nl=STRING "]")?
protected class Label_Group extends GroupToken {
	
	public Label_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLabelAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Label_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Label_EnAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getLabelRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// en=STRING
protected class Label_EnAssignment_0 extends AssignmentToken  {
	
	public Label_EnAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLabelAccess().getEnAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("en",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("en");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getLabelAccess().getEnSTRINGTerminalRuleCall_0_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getLabelAccess().getEnSTRINGTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("[nl:" nl=STRING "]")?
protected class Label_Group_1 extends GroupToken {
	
	public Label_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLabelAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Label_RightSquareBracketKeyword_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "[nl:"
protected class Label_NlKeyword_1_0 extends KeywordToken  {
	
	public Label_NlKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLabelAccess().getNlKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Label_EnAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// nl=STRING
protected class Label_NlAssignment_1_1 extends AssignmentToken  {
	
	public Label_NlAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLabelAccess().getNlAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Label_NlKeyword_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("nl",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("nl");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getLabelAccess().getNlSTRINGTerminalRuleCall_1_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getLabelAccess().getNlSTRINGTerminalRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// "]"
protected class Label_RightSquareBracketKeyword_1_2 extends KeywordToken  {
	
	public Label_RightSquareBracketKeyword_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLabelAccess().getRightSquareBracketKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Label_NlAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule Label ****************/


/************ begin Rule PathTail ****************
 *
 * PathTail:
 * 	"/" field=[data::Field] ("(" asEntity=[data::Entity] ")")? tail=PathTail?;
 *
 **/

// "/" field=[data::Field] ("(" asEntity=[data::Entity] ")")? tail=PathTail?
protected class PathTail_Group extends GroupToken {
	
	public PathTail_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPathTailAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PathTail_TailAssignment_3(lastRuleCallOrigin, this, 0, inst);
			case 1: return new PathTail_Group_2(lastRuleCallOrigin, this, 1, inst);
			case 2: return new PathTail_FieldAssignment_1(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPathTailRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "/"
protected class PathTail_SolidusKeyword_0 extends KeywordToken  {
	
	public PathTail_SolidusKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPathTailAccess().getSolidusKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// field=[data::Field]
protected class PathTail_FieldAssignment_1 extends AssignmentToken  {
	
	public PathTail_FieldAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPathTailAccess().getFieldAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PathTail_SolidusKeyword_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("field",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("field");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPathTailAccess().getFieldFieldCrossReference_1_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getPathTailAccess().getFieldFieldCrossReference_1_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("(" asEntity=[data::Entity] ")")?
protected class PathTail_Group_2 extends GroupToken {
	
	public PathTail_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPathTailAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PathTail_RightParenthesisKeyword_2_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class PathTail_LeftParenthesisKeyword_2_0 extends KeywordToken  {
	
	public PathTail_LeftParenthesisKeyword_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPathTailAccess().getLeftParenthesisKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PathTail_FieldAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// asEntity=[data::Entity]
protected class PathTail_AsEntityAssignment_2_1 extends AssignmentToken  {
	
	public PathTail_AsEntityAssignment_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPathTailAccess().getAsEntityAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PathTail_LeftParenthesisKeyword_2_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("asEntity",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("asEntity");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPathTailAccess().getAsEntityEntityCrossReference_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getPathTailAccess().getAsEntityEntityCrossReference_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ")"
protected class PathTail_RightParenthesisKeyword_2_2 extends KeywordToken  {
	
	public PathTail_RightParenthesisKeyword_2_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPathTailAccess().getRightParenthesisKeyword_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PathTail_AsEntityAssignment_2_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


// tail=PathTail?
protected class PathTail_TailAssignment_3 extends AssignmentToken  {
	
	public PathTail_TailAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPathTailAccess().getTailAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PathTail_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("tail",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("tail");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPathTailRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getPathTailAccess().getTailPathTailParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PathTail_Group_2(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new PathTail_FieldAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule PathTail ****************/


/************ begin Rule Declaration ****************
 *
 * / * scoping:
 *      * if asEntity is present, then:
 *      *  1) the type of element must be an entity,
 *      *  2) asEntity must be a proper sub entity of the type of element.
 *      * // *
 * DataStorePathHead:
 *     '[' dataStore=[DataStore] ']' tail=PathTail
 *     ;
 * * // *
 *  * +--------------+
 *  * | Declarations |
 *  * +--------------+
 *  * /// TODO  give aliases, enumeration list definitions and conditions their own segment ('aliases:', &c)
 * //          as soon as the current format turns out to be unwieldy (saves some filtering as well)
 * Declaration:
 * 	ExternalVariable | EnumList | DataStore;
 *
 **/

// ExternalVariable | EnumList | DataStore
protected class Declaration_Alternatives extends AlternativesToken {

	public Declaration_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Declaration_ExternalVariableParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Declaration_EnumListParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new Declaration_DataStoreParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDataStoreRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEnumListRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getExternalVariableRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ExternalVariable
protected class Declaration_ExternalVariableParserRuleCall_0 extends RuleCallToken {
	
	public Declaration_ExternalVariableParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getExternalVariableParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ExternalVariable_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExternalVariableRule().getType().getClassifier())
			return null;
		if(checkForRecursion(ExternalVariable_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// EnumList
protected class Declaration_EnumListParserRuleCall_1 extends RuleCallToken {
	
	public Declaration_EnumListParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getEnumListParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumList_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEnumListRule().getType().getClassifier())
			return null;
		if(checkForRecursion(EnumList_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// DataStore
protected class Declaration_DataStoreParserRuleCall_2 extends RuleCallToken {
	
	public Declaration_DataStoreParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getDataStoreParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DataStore_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDataStoreRule().getType().getClassifier())
			return null;
		if(checkForRecursion(DataStore_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Declaration ****************/


/************ begin Rule ExternalVariable ****************
 *
 * // alias to path inside declared view class
 * // (may only be static and not be present on the screen)
 * ExternalVariable:
 * 	"external-var" path=PathTail "as" name=ID;
 *
 **/

// "external-var" path=PathTail "as" name=ID
protected class ExternalVariable_Group extends GroupToken {
	
	public ExternalVariable_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExternalVariableAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ExternalVariable_NameAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExternalVariableRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "external-var"
protected class ExternalVariable_ExternalVarKeyword_0 extends KeywordToken  {
	
	public ExternalVariable_ExternalVarKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getExternalVariableAccess().getExternalVarKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// path=PathTail
protected class ExternalVariable_PathAssignment_1 extends AssignmentToken  {
	
	public ExternalVariable_PathAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExternalVariableAccess().getPathAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PathTail_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("path",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("path");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPathTailRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getExternalVariableAccess().getPathPathTailParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ExternalVariable_ExternalVarKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "as"
protected class ExternalVariable_AsKeyword_2 extends KeywordToken  {
	
	public ExternalVariable_AsKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getExternalVariableAccess().getAsKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ExternalVariable_PathAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// name=ID
protected class ExternalVariable_NameAssignment_3 extends AssignmentToken  {
	
	public ExternalVariable_NameAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExternalVariableAccess().getNameAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ExternalVariable_AsKeyword_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getExternalVariableAccess().getNameIDTerminalRuleCall_3_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getExternalVariableAccess().getNameIDTerminalRuleCall_3_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule ExternalVariable ****************/


/************ begin Rule EnumList ****************
 *
 * EnumList:
 * 	"define" name=ID "as" "(" literals+=[data::EnumLiteral]+ ")" "of" ^enum=[data::Enumeration];
 *
 **/

// "define" name=ID "as" "(" literals+=[data::EnumLiteral]+ ")" "of" ^enum=[data::Enumeration]
protected class EnumList_Group extends GroupToken {
	
	public EnumList_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumListAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumList_EnumAssignment_7(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEnumListRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "define"
protected class EnumList_DefineKeyword_0 extends KeywordToken  {
	
	public EnumList_DefineKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumListAccess().getDefineKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// name=ID
protected class EnumList_NameAssignment_1 extends AssignmentToken  {
	
	public EnumList_NameAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumListAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumList_DefineKeyword_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getEnumListAccess().getNameIDTerminalRuleCall_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getEnumListAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "as"
protected class EnumList_AsKeyword_2 extends KeywordToken  {
	
	public EnumList_AsKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumListAccess().getAsKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumList_NameAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class EnumList_LeftParenthesisKeyword_3 extends KeywordToken  {
	
	public EnumList_LeftParenthesisKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumListAccess().getLeftParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumList_AsKeyword_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// literals+=[data::EnumLiteral]+
protected class EnumList_LiteralsAssignment_4 extends AssignmentToken  {
	
	public EnumList_LiteralsAssignment_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumListAccess().getLiteralsAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumList_LiteralsAssignment_4(lastRuleCallOrigin, this, 0, inst);
			case 1: return new EnumList_LeftParenthesisKeyword_3(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("literals",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("literals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumListAccess().getLiteralsEnumLiteralCrossReference_4_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getEnumListAccess().getLiteralsEnumLiteralCrossReference_4_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ")"
protected class EnumList_RightParenthesisKeyword_5 extends KeywordToken  {
	
	public EnumList_RightParenthesisKeyword_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumListAccess().getRightParenthesisKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumList_LiteralsAssignment_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "of"
protected class EnumList_OfKeyword_6 extends KeywordToken  {
	
	public EnumList_OfKeyword_6(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumListAccess().getOfKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumList_RightParenthesisKeyword_5(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ^enum=[data::Enumeration]
protected class EnumList_EnumAssignment_7 extends AssignmentToken  {
	
	public EnumList_EnumAssignment_7(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumListAccess().getEnumAssignment_7();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumList_OfKeyword_6(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("enum",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("enum");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumListAccess().getEnumEnumerationCrossReference_7_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getEnumListAccess().getEnumEnumerationCrossReference_7_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule EnumList ****************/


/************ begin Rule DataStore ****************
 *
 * / * scoping:
 *      * all literals must be a member of that resolved data::Enumeration
 *      * /DataStore:
 * 	"data-store" name=ID "of-type" class=[data::Entity] multi?="is-multi-valued"?;
 *
 **/

// "data-store" name=ID "of-type" class=[data::Entity] multi?="is-multi-valued"?
protected class DataStore_Group extends GroupToken {
	
	public DataStore_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDataStoreAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DataStore_MultiAssignment_4(lastRuleCallOrigin, this, 0, inst);
			case 1: return new DataStore_ClassAssignment_3(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDataStoreRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "data-store"
protected class DataStore_DataStoreKeyword_0 extends KeywordToken  {
	
	public DataStore_DataStoreKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDataStoreAccess().getDataStoreKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// name=ID
protected class DataStore_NameAssignment_1 extends AssignmentToken  {
	
	public DataStore_NameAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDataStoreAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DataStore_DataStoreKeyword_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getDataStoreAccess().getNameIDTerminalRuleCall_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getDataStoreAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "of-type"
protected class DataStore_OfTypeKeyword_2 extends KeywordToken  {
	
	public DataStore_OfTypeKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDataStoreAccess().getOfTypeKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DataStore_NameAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// class=[data::Entity]
protected class DataStore_ClassAssignment_3 extends AssignmentToken  {
	
	public DataStore_ClassAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDataStoreAccess().getClassAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DataStore_OfTypeKeyword_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("class",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("class");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDataStoreAccess().getClassEntityCrossReference_3_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getDataStoreAccess().getClassEntityCrossReference_3_0(); 
				return obj;
			}
		}
		return null;
	}

}

// multi?="is-multi-valued"?
protected class DataStore_MultiAssignment_4 extends AssignmentToken  {
	
	public DataStore_MultiAssignment_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDataStoreAccess().getMultiAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DataStore_ClassAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("multi",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("multi");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KEYWORD;
			element = grammarAccess.getDataStoreAccess().getMultiIsMultiValuedKeyword_4_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule DataStore ****************/


/************ begin Rule GroupElement ****************
 *
 * / *
 *  * +------------------+
 *  * | Screen structure |
 *  * +------------------+
 *  * /GroupElement:
 * 	Field | FieldGroup;
 *
 **/

// Field | FieldGroup
protected class GroupElement_Alternatives extends AlternativesToken {

	public GroupElement_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getGroupElementAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new GroupElement_FieldParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new GroupElement_FieldGroupParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFieldRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getFieldGroupRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Field
protected class GroupElement_FieldParserRuleCall_0 extends RuleCallToken {
	
	public GroupElement_FieldParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getGroupElementAccess().getFieldParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Field_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFieldRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Field_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// FieldGroup
protected class GroupElement_FieldGroupParserRuleCall_1 extends RuleCallToken {
	
	public GroupElement_FieldGroupParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getGroupElementAccess().getFieldGroupParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FieldGroup_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFieldGroupRule().getType().getClassifier())
			return null;
		if(checkForRecursion(FieldGroup_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule GroupElement ****************/


/************ begin Rule Field ****************
 *
 * Field:
 * 	name=ID label=Label path=PathTail attributes+=Attribute*;
 *
 **/

// name=ID label=Label path=PathTail attributes+=Attribute*
protected class Field_Group extends GroupToken {
	
	public Field_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFieldAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Field_AttributesAssignment_3(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Field_PathAssignment_2(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFieldRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// name=ID
protected class Field_NameAssignment_0 extends AssignmentToken  {
	
	public Field_NameAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getFieldAccess().getNameIDTerminalRuleCall_0_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getFieldAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// label=Label
protected class Field_LabelAssignment_1 extends AssignmentToken  {
	
	public Field_LabelAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldAccess().getLabelAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Label_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("label",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("label");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLabelRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getFieldAccess().getLabelLabelParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Field_NameAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// path=PathTail
protected class Field_PathAssignment_2 extends AssignmentToken  {
	
	public Field_PathAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldAccess().getPathAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PathTail_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("path",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("path");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPathTailRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getFieldAccess().getPathPathTailParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Field_LabelAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// attributes+=Attribute*
protected class Field_AttributesAssignment_3 extends AssignmentToken  {
	
	public Field_AttributesAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldAccess().getAttributesAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Attribute_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("attributes",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("attributes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getFieldAccess().getAttributesAttributeParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Field_AttributesAssignment_3(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Field_PathAssignment_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Field ****************/


/************ begin Rule FieldGroup ****************
 *
 * FieldGroup:
 * 	"group" label=Label? ("with" ^with=PathTail)? "{" elements+=GroupElement+ "}" attributes+=Attribute*;
 *
 **/

// "group" label=Label? ("with" ^with=PathTail)? "{" elements+=GroupElement+ "}" attributes+=Attribute*
protected class FieldGroup_Group extends GroupToken {
	
	public FieldGroup_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFieldGroupAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FieldGroup_AttributesAssignment_6(lastRuleCallOrigin, this, 0, inst);
			case 1: return new FieldGroup_RightCurlyBracketKeyword_5(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFieldGroupRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "group"
protected class FieldGroup_GroupKeyword_0 extends KeywordToken  {
	
	public FieldGroup_GroupKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFieldGroupAccess().getGroupKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// label=Label?
protected class FieldGroup_LabelAssignment_1 extends AssignmentToken  {
	
	public FieldGroup_LabelAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldGroupAccess().getLabelAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Label_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("label",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("label");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLabelRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getFieldGroupAccess().getLabelLabelParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FieldGroup_GroupKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("with" ^with=PathTail)?
protected class FieldGroup_Group_2 extends GroupToken {
	
	public FieldGroup_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFieldGroupAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FieldGroup_WithAssignment_2_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "with"
protected class FieldGroup_WithKeyword_2_0 extends KeywordToken  {
	
	public FieldGroup_WithKeyword_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFieldGroupAccess().getWithKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FieldGroup_LabelAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new FieldGroup_GroupKeyword_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// ^with=PathTail
protected class FieldGroup_WithAssignment_2_1 extends AssignmentToken  {
	
	public FieldGroup_WithAssignment_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldGroupAccess().getWithAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PathTail_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("with",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("with");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPathTailRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getFieldGroupAccess().getWithPathTailParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FieldGroup_WithKeyword_2_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "{"
protected class FieldGroup_LeftCurlyBracketKeyword_3 extends KeywordToken  {
	
	public FieldGroup_LeftCurlyBracketKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFieldGroupAccess().getLeftCurlyBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FieldGroup_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new FieldGroup_LabelAssignment_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new FieldGroup_GroupKeyword_0(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

}

// elements+=GroupElement+
protected class FieldGroup_ElementsAssignment_4 extends AssignmentToken  {
	
	public FieldGroup_ElementsAssignment_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldGroupAccess().getElementsAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new GroupElement_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("elements",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("elements");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGroupElementRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getFieldGroupAccess().getElementsGroupElementParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FieldGroup_ElementsAssignment_4(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new FieldGroup_LeftCurlyBracketKeyword_3(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class FieldGroup_RightCurlyBracketKeyword_5 extends KeywordToken  {
	
	public FieldGroup_RightCurlyBracketKeyword_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFieldGroupAccess().getRightCurlyBracketKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FieldGroup_ElementsAssignment_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// attributes+=Attribute*
protected class FieldGroup_AttributesAssignment_6 extends AssignmentToken  {
	
	public FieldGroup_AttributesAssignment_6(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldGroupAccess().getAttributesAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Attribute_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("attributes",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("attributes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getFieldGroupAccess().getAttributesAttributeParserRuleCall_6_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FieldGroup_AttributesAssignment_6(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new FieldGroup_RightCurlyBracketKeyword_5(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule FieldGroup ****************/


/************ begin Rule Attribute ****************
 *
 * / * semantics:
 *      * The paths inside (anywhere) within this group are considered relative
 *      *  to the 'with' path (which itself may be relative to some group instead
 *      *  of the declared view class). Note that the semantics of Field.path
 *      *  also change to be relative.
 *      * The attributes declared at group-level can be overridden at the field-level.
 *      * // * validations:
 *      * For top-level groups, a label is required.
 *      * // *
 *  * +------------------+
 *  * | Field attributes |
 *  * +------------------+
 *  * /Attribute:
 * 	NormalAttribute | EnumFieldAttribute;
 *
 **/

// NormalAttribute | EnumFieldAttribute
protected class Attribute_Alternatives extends AlternativesToken {

	public Attribute_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAttributeAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Attribute_NormalAttributeParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Attribute_EnumFieldAttributeParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNormalAttributeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getRestrictionAttributeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getRestrictionGroupAttributeAccess().getRestrictionGroupAttributeAction_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// NormalAttribute
protected class Attribute_NormalAttributeParserRuleCall_0 extends RuleCallToken {
	
	public Attribute_NormalAttributeParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAttributeAccess().getNormalAttributeParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NormalAttribute_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNormalAttributeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(NormalAttribute_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// EnumFieldAttribute
protected class Attribute_EnumFieldAttributeParserRuleCall_1 extends RuleCallToken {
	
	public Attribute_EnumFieldAttributeParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAttributeAccess().getEnumFieldAttributeParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumFieldAttribute_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getRestrictionAttributeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getRestrictionGroupAttributeAccess().getRestrictionGroupAttributeAction_0().getType().getClassifier())
			return null;
		if(checkForRecursion(EnumFieldAttribute_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Attribute ****************/


/************ begin Rule EnumFieldAttribute ****************
 *
 * EnumFieldAttribute:
 * 	RestrictionAttribute | RestrictionGroupAttribute;
 *
 **/

// RestrictionAttribute | RestrictionGroupAttribute
protected class EnumFieldAttribute_Alternatives extends AlternativesToken {

	public EnumFieldAttribute_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getEnumFieldAttributeAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumFieldAttribute_RestrictionAttributeParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new EnumFieldAttribute_RestrictionGroupAttributeParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getRestrictionAttributeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getRestrictionGroupAttributeAccess().getRestrictionGroupAttributeAction_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// RestrictionAttribute
protected class EnumFieldAttribute_RestrictionAttributeParserRuleCall_0 extends RuleCallToken {
	
	public EnumFieldAttribute_RestrictionAttributeParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumFieldAttributeAccess().getRestrictionAttributeParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new RestrictionAttribute_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getRestrictionAttributeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(RestrictionAttribute_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// RestrictionGroupAttribute
protected class EnumFieldAttribute_RestrictionGroupAttributeParserRuleCall_1 extends RuleCallToken {
	
	public EnumFieldAttribute_RestrictionGroupAttributeParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumFieldAttributeAccess().getRestrictionGroupAttributeParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new RestrictionGroupAttribute_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getRestrictionGroupAttributeAccess().getRestrictionGroupAttributeAction_0().getType().getClassifier())
			return null;
		if(checkForRecursion(RestrictionGroupAttribute_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule EnumFieldAttribute ****************/


/************ begin Rule NormalAttribute ****************
 *
 * NormalAttribute:
 * 	classExpr=AttributeClassExpression ("if" clause=BExpression)?;
 *
 **/

// classExpr=AttributeClassExpression ("if" clause=BExpression)?
protected class NormalAttribute_Group extends GroupToken {
	
	public NormalAttribute_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNormalAttributeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NormalAttribute_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new NormalAttribute_ClassExprAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNormalAttributeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// classExpr=AttributeClassExpression
protected class NormalAttribute_ClassExprAssignment_0 extends AssignmentToken  {
	
	public NormalAttribute_ClassExprAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNormalAttributeAccess().getClassExprAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AttributeClassExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("classExpr",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("classExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeClassExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNormalAttributeAccess().getClassExprAttributeClassExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// ("if" clause=BExpression)?
protected class NormalAttribute_Group_1 extends GroupToken {
	
	public NormalAttribute_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNormalAttributeAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NormalAttribute_ClauseAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "if"
protected class NormalAttribute_IfKeyword_1_0 extends KeywordToken  {
	
	public NormalAttribute_IfKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNormalAttributeAccess().getIfKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NormalAttribute_ClassExprAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// clause=BExpression
protected class NormalAttribute_ClauseAssignment_1_1 extends AssignmentToken  {
	
	public NormalAttribute_ClauseAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNormalAttributeAccess().getClauseAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BExpression_BOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("clause",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("clause");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNormalAttributeAccess().getClauseBExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NormalAttribute_IfKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule NormalAttribute ****************/


/************ begin Rule AttributeClassExpression ****************
 *
 * / * semantics:
 *      * 'if' means 'if and only if' (i.e., 'iff').
 *      * /AttributeClassExpression:
 * 	classes+=AttributeClass ("+" classes+=AttributeClass)*;
 *
 **/

// classes+=AttributeClass ("+" classes+=AttributeClass)*
protected class AttributeClassExpression_Group extends GroupToken {
	
	public AttributeClassExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeClassExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AttributeClassExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AttributeClassExpression_ClassesAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAttributeClassExpressionRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// classes+=AttributeClass
protected class AttributeClassExpression_ClassesAssignment_0 extends AssignmentToken  {
	
	public AttributeClassExpression_ClassesAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeClassExpressionAccess().getClassesAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("classes",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("classes");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getAttributeClassExpressionAccess().getClassesAttributeClassEnumRuleCall_0_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getAttributeClassExpressionAccess().getClassesAttributeClassEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("+" classes+=AttributeClass)*
protected class AttributeClassExpression_Group_1 extends GroupToken {
	
	public AttributeClassExpression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeClassExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AttributeClassExpression_ClassesAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "+"
protected class AttributeClassExpression_PlusSignKeyword_1_0 extends KeywordToken  {
	
	public AttributeClassExpression_PlusSignKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeClassExpressionAccess().getPlusSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AttributeClassExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AttributeClassExpression_ClassesAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// classes+=AttributeClass
protected class AttributeClassExpression_ClassesAssignment_1_1 extends AssignmentToken  {
	
	public AttributeClassExpression_ClassesAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeClassExpressionAccess().getClassesAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AttributeClassExpression_PlusSignKeyword_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("classes",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("classes");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getAttributeClassExpressionAccess().getClassesAttributeClassEnumRuleCall_1_1_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getAttributeClassExpressionAccess().getClassesAttributeClassEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule AttributeClassExpression ****************/


/************ begin Rule RestrictionAttribute ****************
 *
 * RestrictionAttribute:
 * 	"restrict-to" literals=EnumLiteralsCollection "if" clause=BExpression;
 *
 **/

// "restrict-to" literals=EnumLiteralsCollection "if" clause=BExpression
protected class RestrictionAttribute_Group extends GroupToken {
	
	public RestrictionAttribute_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRestrictionAttributeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new RestrictionAttribute_ClauseAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getRestrictionAttributeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "restrict-to"
protected class RestrictionAttribute_RestrictToKeyword_0 extends KeywordToken  {
	
	public RestrictionAttribute_RestrictToKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRestrictionAttributeAccess().getRestrictToKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// literals=EnumLiteralsCollection
protected class RestrictionAttribute_LiteralsAssignment_1 extends AssignmentToken  {
	
	public RestrictionAttribute_LiteralsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRestrictionAttributeAccess().getLiteralsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumLiteralsCollection_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("literals",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("literals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumLiteralsCollectionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getRestrictionAttributeAccess().getLiteralsEnumLiteralsCollectionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RestrictionAttribute_RestrictToKeyword_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "if"
protected class RestrictionAttribute_IfKeyword_2 extends KeywordToken  {
	
	public RestrictionAttribute_IfKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRestrictionAttributeAccess().getIfKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new RestrictionAttribute_LiteralsAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// clause=BExpression
protected class RestrictionAttribute_ClauseAssignment_3 extends AssignmentToken  {
	
	public RestrictionAttribute_ClauseAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRestrictionAttributeAccess().getClauseAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BExpression_BOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("clause",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("clause");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getRestrictionAttributeAccess().getClauseBExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RestrictionAttribute_IfKeyword_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule RestrictionAttribute ****************/


/************ begin Rule RestrictionGroupAttribute ****************
 *
 * / * validation:
 *      * Can only be used if the (enclosing) field has a data::Enumeration as type.
 *      * scoping:
 *      * The literals must be owned by the Enumeration type of the (enclosing) field.
 *      * semantics:
 *      * If the clause expression evaluates to true, the possible values for the (enclosing)
 *      * Enumeration field should be restricted to the given list.
 *      * TODO  what to do with overlap in the clauses? evaluation in order?
 *      * /RestrictionGroupAttribute: // make sure an object is created even with no rules, to trigger the validation on enum type
 * 	{RestrictionGroupAttribute} "restrict-to-group" "<" rules+=RestrictionRule+ ">";
 *
 **/

// // make sure an object is created even with no rules, to trigger the validation on enum type
// {RestrictionGroupAttribute} "restrict-to-group" "<" rules+=RestrictionRule+ ">"
protected class RestrictionGroupAttribute_Group extends GroupToken {
	
	public RestrictionGroupAttribute_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRestrictionGroupAttributeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new RestrictionGroupAttribute_GreaterThanSignKeyword_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getRestrictionGroupAttributeAccess().getRestrictionGroupAttributeAction_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// // make sure an object is created even with no rules, to trigger the validation on enum type
// {RestrictionGroupAttribute}
protected class RestrictionGroupAttribute_RestrictionGroupAttributeAction_0 extends ActionToken  {

	public RestrictionGroupAttribute_RestrictionGroupAttributeAction_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getRestrictionGroupAttributeAccess().getRestrictionGroupAttributeAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(!eObjectConsumer.isConsumed()) return null;
		return eObjectConsumer;
	}
}

// "restrict-to-group"
protected class RestrictionGroupAttribute_RestrictToGroupKeyword_1 extends KeywordToken  {
	
	public RestrictionGroupAttribute_RestrictToGroupKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRestrictionGroupAttributeAccess().getRestrictToGroupKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new RestrictionGroupAttribute_RestrictionGroupAttributeAction_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "<"
protected class RestrictionGroupAttribute_LessThanSignKeyword_2 extends KeywordToken  {
	
	public RestrictionGroupAttribute_LessThanSignKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRestrictionGroupAttributeAccess().getLessThanSignKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new RestrictionGroupAttribute_RestrictToGroupKeyword_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rules+=RestrictionRule+
protected class RestrictionGroupAttribute_RulesAssignment_3 extends AssignmentToken  {
	
	public RestrictionGroupAttribute_RulesAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRestrictionGroupAttributeAccess().getRulesAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new RestrictionRule_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rules",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rules");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRestrictionRuleRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getRestrictionGroupAttributeAccess().getRulesRestrictionRuleParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RestrictionGroupAttribute_RulesAssignment_3(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new RestrictionGroupAttribute_LessThanSignKeyword_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ">"
protected class RestrictionGroupAttribute_GreaterThanSignKeyword_4 extends KeywordToken  {
	
	public RestrictionGroupAttribute_GreaterThanSignKeyword_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRestrictionGroupAttributeAccess().getGreaterThanSignKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new RestrictionGroupAttribute_RulesAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule RestrictionGroupAttribute ****************/


/************ begin Rule RestrictionRule ****************
 *
 * RestrictionRule:
 * 	literals=EnumLiteralsCollection "if" clause=BExpression;
 *
 **/

// literals=EnumLiteralsCollection "if" clause=BExpression
protected class RestrictionRule_Group extends GroupToken {
	
	public RestrictionRule_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRestrictionRuleAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new RestrictionRule_ClauseAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getRestrictionRuleRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// literals=EnumLiteralsCollection
protected class RestrictionRule_LiteralsAssignment_0 extends AssignmentToken  {
	
	public RestrictionRule_LiteralsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRestrictionRuleAccess().getLiteralsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumLiteralsCollection_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("literals",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("literals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumLiteralsCollectionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getRestrictionRuleAccess().getLiteralsEnumLiteralsCollectionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// "if"
protected class RestrictionRule_IfKeyword_1 extends KeywordToken  {
	
	public RestrictionRule_IfKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRestrictionRuleAccess().getIfKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new RestrictionRule_LiteralsAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// clause=BExpression
protected class RestrictionRule_ClauseAssignment_2 extends AssignmentToken  {
	
	public RestrictionRule_ClauseAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRestrictionRuleAccess().getClauseAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BExpression_BOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("clause",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("clause");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getRestrictionRuleAccess().getClauseBExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RestrictionRule_IfKeyword_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule RestrictionRule ****************/


/************ begin Rule ReferenceTarget ****************
 *
 * / * scoping:
 *      * Same as (and already taken of by scoping implementation) for RestrictionAttribute.literals
 *      * // *
 *  * +------------+
 *  * | References |
 *  * +------------+
 *  * /ReferenceTarget:
 * 	Field | ExternalVariable;
 *
 **/

// Field | ExternalVariable
protected class ReferenceTarget_Alternatives extends AlternativesToken {

	public ReferenceTarget_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getReferenceTargetAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ReferenceTarget_FieldParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ReferenceTarget_ExternalVariableParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExternalVariableRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getFieldRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Field
protected class ReferenceTarget_FieldParserRuleCall_0 extends RuleCallToken {
	
	public ReferenceTarget_FieldParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getReferenceTargetAccess().getFieldParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Field_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFieldRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Field_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ExternalVariable
protected class ReferenceTarget_ExternalVariableParserRuleCall_1 extends RuleCallToken {
	
	public ReferenceTarget_ExternalVariableParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getReferenceTargetAccess().getExternalVariableParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ExternalVariable_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExternalVariableRule().getType().getClassifier())
			return null;
		if(checkForRecursion(ExternalVariable_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule ReferenceTarget ****************/


/************ begin Rule Reference ****************
 *
 * Reference:
 * 	ref=[ReferenceTarget];
 *
 **/

// ref=[ReferenceTarget]
protected class Reference_RefAssignment extends AssignmentToken  {
	
	public Reference_RefAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReferenceAccess().getRefAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getReferenceRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("ref",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ref");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReferenceAccess().getRefReferenceTargetCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getReferenceAccess().getRefReferenceTargetCrossReference_0(); 
				return obj;
			}
		}
		return null;
	}

}

/************ end Rule Reference ****************/


/************ begin Rule DummyForExternalVariable ****************
 *
 * / *
 *  * This dummy type rule is needed because of the 'pull features up' transformation
 *  * of the Ecore models generated from Xtext grammars. Without this, the Ecore ends up
 *  * with the following elements:
 *  *
 *  * Declaration: name(ID)
 *  * ReferenceTarget: name(ID) (, path)
 *  * ExternalVariable -> Declaration, ReferenceTarget
 *  *
 *  * This would lead to duplicate generation of a field 'ALIAS__NAME' in DynamismDslPackage.
 *  * /DummyForExternalVariable:
 * 	Declaration | ReferenceTarget;
 *
 **/

// Declaration | ReferenceTarget
protected class DummyForExternalVariable_Alternatives extends AlternativesToken {

	public DummyForExternalVariable_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getDummyForExternalVariableAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DummyForExternalVariable_DeclarationParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new DummyForExternalVariable_ReferenceTargetParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDataStoreRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEnumListRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getExternalVariableRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getFieldRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// Declaration
protected class DummyForExternalVariable_DeclarationParserRuleCall_0 extends RuleCallToken {
	
	public DummyForExternalVariable_DeclarationParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDummyForExternalVariableAccess().getDeclarationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Declaration_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDataStoreRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEnumListRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getExternalVariableRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Declaration_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ReferenceTarget
protected class DummyForExternalVariable_ReferenceTargetParserRuleCall_1 extends RuleCallToken {
	
	public DummyForExternalVariable_ReferenceTargetParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDummyForExternalVariableAccess().getReferenceTargetParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ReferenceTarget_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExternalVariableRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getFieldRule().getType().getClassifier())
			return null;
		if(checkForRecursion(ReferenceTarget_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule DummyForExternalVariable ****************/


/************ begin Rule BExpression ****************
 *
 * / *
 *  * +---------------------+
 *  * | Boolean expressions |
 *  * +---------------------+
 *  *
 *  * Note: in the following, a solitary 'B' within a camel-cased word
 *  * always serves as an abbreviation of 'Boolean'.
 *  *
 *  * FIXME  grammar ambiguity, due to the fact that operator precedence currently doesn't behave nicely
 *  * TODO   rewrite expression grammar to conform with Best Practices (for now: leave as is...)
 *  * /// boolean expression tree-building:
 * BExpression:
 * 	BOrExpression;
 *
 **/

// BOrExpression
protected class BExpression_BOrExpressionParserRuleCall extends RuleCallToken {
	
	public BExpression_BOrExpressionParserRuleCall(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getBExpressionAccess().getBOrExpressionParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BOrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBAndExpressionAccess().getAndOperationLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBComparisonAccess().getBComparisonAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNegationExpressionAccess().getNegationExpressionAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBOrExpressionAccess().getOrOperationLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPresenceCheckRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSingleEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringValueComparisonRule().getType().getClassifier())
			return null;
		if(checkForRecursion(BOrExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule BExpression ****************/


/************ begin Rule BOrExpression ****************
 *
 * BOrExpression returns BExpression:
 * 	BAndExpression ({OrOperation.left=current} ("or" | "|") right=BAndExpression)*;
 *
 **/

// BAndExpression ({OrOperation.left=current} ("or" | "|") right=BAndExpression)*
protected class BOrExpression_Group extends GroupToken {
	
	public BOrExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBOrExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BOrExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new BOrExpression_BAndExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBAndExpressionAccess().getAndOperationLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBComparisonAccess().getBComparisonAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNegationExpressionAccess().getNegationExpressionAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBOrExpressionAccess().getOrOperationLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPresenceCheckRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSingleEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringValueComparisonRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// BAndExpression
protected class BOrExpression_BAndExpressionParserRuleCall_0 extends RuleCallToken {
	
	public BOrExpression_BAndExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getBOrExpressionAccess().getBAndExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BAndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(BAndExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({OrOperation.left=current} ("or" | "|") right=BAndExpression)*
protected class BOrExpression_Group_1 extends GroupToken {
	
	public BOrExpression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBOrExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BOrExpression_RightAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBOrExpressionAccess().getOrOperationLeftAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {OrOperation.left=current}
protected class BOrExpression_OrOperationLeftAction_1_0 extends ActionToken  {

	public BOrExpression_OrOperationLeftAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBOrExpressionAccess().getOrOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BOrExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new BOrExpression_BAndExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("left", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("left")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "or" | "|"
protected class BOrExpression_Alternatives_1_1 extends AlternativesToken {

	public BOrExpression_Alternatives_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBOrExpressionAccess().getAlternatives_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BOrExpression_OrKeyword_1_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "or"
protected class BOrExpression_OrKeyword_1_1_0 extends KeywordToken  {
	
	public BOrExpression_OrKeyword_1_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBOrExpressionAccess().getOrKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BOrExpression_OrOperationLeftAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


// right=BAndExpression
protected class BOrExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public BOrExpression_RightAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBOrExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BAndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("right",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getBOrExpressionAccess().getRightBAndExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BOrExpression_Alternatives_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule BOrExpression ****************/


/************ begin Rule BAndExpression ****************
 *
 * BAndExpression returns BExpression:
 * 	NegationExpression ({AndOperation.left=current} ("and" | "&") right=NegationExpression)*;
 *
 **/

// NegationExpression ({AndOperation.left=current} ("and" | "&") right=NegationExpression)*
protected class BAndExpression_Group extends GroupToken {
	
	public BAndExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBAndExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BAndExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new BAndExpression_NegationExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBAndExpressionAccess().getAndOperationLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBComparisonAccess().getBComparisonAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNegationExpressionAccess().getNegationExpressionAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBOrExpressionAccess().getOrOperationLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPresenceCheckRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSingleEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringValueComparisonRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// NegationExpression
protected class BAndExpression_NegationExpressionParserRuleCall_0 extends RuleCallToken {
	
	public BAndExpression_NegationExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getBAndExpressionAccess().getNegationExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NegationExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(NegationExpression_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({AndOperation.left=current} ("and" | "&") right=NegationExpression)*
protected class BAndExpression_Group_1 extends GroupToken {
	
	public BAndExpression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBAndExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BAndExpression_RightAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBAndExpressionAccess().getAndOperationLeftAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {AndOperation.left=current}
protected class BAndExpression_AndOperationLeftAction_1_0 extends ActionToken  {

	public BAndExpression_AndOperationLeftAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBAndExpressionAccess().getAndOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BAndExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new BAndExpression_NegationExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("left", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("left")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "and" | "&"
protected class BAndExpression_Alternatives_1_1 extends AlternativesToken {

	public BAndExpression_Alternatives_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBAndExpressionAccess().getAlternatives_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BAndExpression_AndKeyword_1_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "and"
protected class BAndExpression_AndKeyword_1_1_0 extends KeywordToken  {
	
	public BAndExpression_AndKeyword_1_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBAndExpressionAccess().getAndKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BAndExpression_AndOperationLeftAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


// right=NegationExpression
protected class BAndExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public BAndExpression_RightAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBAndExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NegationExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("right",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNegationExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getBAndExpressionAccess().getRightNegationExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BAndExpression_Alternatives_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule BAndExpression ****************/


/************ begin Rule NegationExpression ****************
 *
 * NegationExpression returns BExpression:
 * 	TerminalBExpression | {NegationExpression} ("not" | "!") expr=NegationExpression;
 *
 **/

// TerminalBExpression | {NegationExpression} ("not" | "!") expr=NegationExpression
protected class NegationExpression_Alternatives extends AlternativesToken {

	public NegationExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNegationExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NegationExpression_TerminalBExpressionParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new NegationExpression_Group_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBAndExpressionAccess().getAndOperationLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBComparisonAccess().getBComparisonAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNegationExpressionAccess().getNegationExpressionAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBOrExpressionAccess().getOrOperationLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPresenceCheckRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSingleEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringValueComparisonRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// TerminalBExpression
protected class NegationExpression_TerminalBExpressionParserRuleCall_0 extends RuleCallToken {
	
	public NegationExpression_TerminalBExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNegationExpressionAccess().getTerminalBExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TerminalBExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(TerminalBExpression_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// {NegationExpression} ("not" | "!") expr=NegationExpression
protected class NegationExpression_Group_1 extends GroupToken {
	
	public NegationExpression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNegationExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NegationExpression_ExprAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNegationExpressionAccess().getNegationExpressionAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {NegationExpression}
protected class NegationExpression_NegationExpressionAction_1_0 extends ActionToken  {

	public NegationExpression_NegationExpressionAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getNegationExpressionAccess().getNegationExpressionAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(!eObjectConsumer.isConsumed()) return null;
		return eObjectConsumer;
	}
}

// "not" | "!"
protected class NegationExpression_Alternatives_1_1 extends AlternativesToken {

	public NegationExpression_Alternatives_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNegationExpressionAccess().getAlternatives_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NegationExpression_NotKeyword_1_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "not"
protected class NegationExpression_NotKeyword_1_1_0 extends KeywordToken  {
	
	public NegationExpression_NotKeyword_1_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNegationExpressionAccess().getNotKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NegationExpression_NegationExpressionAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


// expr=NegationExpression
protected class NegationExpression_ExprAssignment_1_2 extends AssignmentToken  {
	
	public NegationExpression_ExprAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNegationExpressionAccess().getExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NegationExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("expr",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("expr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNegationExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNegationExpressionAccess().getExprNegationExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NegationExpression_Alternatives_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule NegationExpression ****************/


/************ begin Rule TerminalBExpression ****************
 *
 * TerminalBExpression returns BExpression:
 * 	AtomicReferringBExpression | "(" BExpression ")";
 *
 **/

// AtomicReferringBExpression | "(" BExpression ")"
protected class TerminalBExpression_Alternatives extends AlternativesToken {

	public TerminalBExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTerminalBExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TerminalBExpression_AtomicReferringBExpressionParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new TerminalBExpression_Group_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBAndExpressionAccess().getAndOperationLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBComparisonAccess().getBComparisonAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNegationExpressionAccess().getNegationExpressionAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBOrExpressionAccess().getOrOperationLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPresenceCheckRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSingleEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringValueComparisonRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// AtomicReferringBExpression
protected class TerminalBExpression_AtomicReferringBExpressionParserRuleCall_0 extends RuleCallToken {
	
	public TerminalBExpression_AtomicReferringBExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalBExpressionAccess().getAtomicReferringBExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AtomicReferringBExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBComparisonAccess().getBComparisonAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPresenceCheckRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSingleEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringValueComparisonRule().getType().getClassifier())
			return null;
		if(checkForRecursion(AtomicReferringBExpression_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// "(" BExpression ")"
protected class TerminalBExpression_Group_1 extends GroupToken {
	
	public TerminalBExpression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalBExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TerminalBExpression_RightParenthesisKeyword_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class TerminalBExpression_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public TerminalBExpression_LeftParenthesisKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTerminalBExpressionAccess().getLeftParenthesisKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// BExpression
protected class TerminalBExpression_BExpressionParserRuleCall_1_1 extends RuleCallToken {
	
	public TerminalBExpression_BExpressionParserRuleCall_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalBExpressionAccess().getBExpressionParserRuleCall_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BExpression_BOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(BExpression_BOrExpressionParserRuleCall.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TerminalBExpression_LeftParenthesisKeyword_1_0(lastRuleCallOrigin, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class TerminalBExpression_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public TerminalBExpression_RightParenthesisKeyword_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTerminalBExpressionAccess().getRightParenthesisKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TerminalBExpression_BExpressionParserRuleCall_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule TerminalBExpression ****************/


/************ begin Rule AtomicReferringBExpression ****************
 *
 * AtomicReferringBExpression:
 * 	BComparison | EnumComparison | StringValueComparison | PresenceCheck;
 *
 **/

// BComparison | EnumComparison | StringValueComparison | PresenceCheck
protected class AtomicReferringBExpression_Alternatives extends AlternativesToken {

	public AtomicReferringBExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAtomicReferringBExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AtomicReferringBExpression_BComparisonParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AtomicReferringBExpression_EnumComparisonParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new AtomicReferringBExpression_StringValueComparisonParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			case 3: return new AtomicReferringBExpression_PresenceCheckParserRuleCall_3(lastRuleCallOrigin, this, 3, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBComparisonAccess().getBComparisonAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getMultiEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPresenceCheckRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSingleEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringValueComparisonRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// BComparison
protected class AtomicReferringBExpression_BComparisonParserRuleCall_0 extends RuleCallToken {
	
	public AtomicReferringBExpression_BComparisonParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomicReferringBExpressionAccess().getBComparisonParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BComparison_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBComparisonAccess().getBComparisonAction_0().getType().getClassifier())
			return null;
		if(checkForRecursion(BComparison_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// EnumComparison
protected class AtomicReferringBExpression_EnumComparisonParserRuleCall_1 extends RuleCallToken {
	
	public AtomicReferringBExpression_EnumComparisonParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomicReferringBExpressionAccess().getEnumComparisonParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumComparison_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getMultiEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSingleEnumComparisonRule().getType().getClassifier())
			return null;
		if(checkForRecursion(EnumComparison_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// StringValueComparison
protected class AtomicReferringBExpression_StringValueComparisonParserRuleCall_2 extends RuleCallToken {
	
	public AtomicReferringBExpression_StringValueComparisonParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomicReferringBExpressionAccess().getStringValueComparisonParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StringValueComparison_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStringValueComparisonRule().getType().getClassifier())
			return null;
		if(checkForRecursion(StringValueComparison_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// PresenceCheck
protected class AtomicReferringBExpression_PresenceCheckParserRuleCall_3 extends RuleCallToken {
	
	public AtomicReferringBExpression_PresenceCheckParserRuleCall_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomicReferringBExpressionAccess().getPresenceCheckParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PresenceCheck_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPresenceCheckRule().getType().getClassifier())
			return null;
		if(checkForRecursion(PresenceCheck_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AtomicReferringBExpression ****************/


/************ begin Rule BComparison ****************
 *
 * BComparison:
 * 	{BComparison} ref=Reference ("is" bLiteral=BLiteral)?;
 *
 **/

// {BComparison} ref=Reference ("is" bLiteral=BLiteral)?
protected class BComparison_Group extends GroupToken {
	
	public BComparison_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBComparisonAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BComparison_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new BComparison_RefAssignment_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBComparisonAccess().getBComparisonAction_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {BComparison}
protected class BComparison_BComparisonAction_0 extends ActionToken  {

	public BComparison_BComparisonAction_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBComparisonAccess().getBComparisonAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(!eObjectConsumer.isConsumed()) return null;
		return eObjectConsumer;
	}
}

// ref=Reference
protected class BComparison_RefAssignment_1 extends AssignmentToken  {
	
	public BComparison_RefAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBComparisonAccess().getRefAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Reference_RefAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ref",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ref");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReferenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getBComparisonAccess().getRefReferenceParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BComparison_BComparisonAction_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("is" bLiteral=BLiteral)?
protected class BComparison_Group_2 extends GroupToken {
	
	public BComparison_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBComparisonAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BComparison_BLiteralAssignment_2_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "is"
protected class BComparison_IsKeyword_2_0 extends KeywordToken  {
	
	public BComparison_IsKeyword_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBComparisonAccess().getIsKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BComparison_RefAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// bLiteral=BLiteral
protected class BComparison_BLiteralAssignment_2_1 extends AssignmentToken  {
	
	public BComparison_BLiteralAssignment_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBComparisonAccess().getBLiteralAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BComparison_IsKeyword_2_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("bLiteral",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("bLiteral");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getBComparisonAccess().getBLiteralBLiteralEnumRuleCall_2_1_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getBComparisonAccess().getBLiteralBLiteralEnumRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule BComparison ****************/


/************ begin Rule EnumComparison ****************
 *
 * EnumComparison:
 * 	SingleEnumComparison | MultiEnumComparison;
 *
 **/

// SingleEnumComparison | MultiEnumComparison
protected class EnumComparison_Alternatives extends AlternativesToken {

	public EnumComparison_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getEnumComparisonAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumComparison_SingleEnumComparisonParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new EnumComparison_MultiEnumComparisonParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getMultiEnumComparisonRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSingleEnumComparisonRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// SingleEnumComparison
protected class EnumComparison_SingleEnumComparisonParserRuleCall_0 extends RuleCallToken {
	
	public EnumComparison_SingleEnumComparisonParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumComparisonAccess().getSingleEnumComparisonParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new SingleEnumComparison_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSingleEnumComparisonRule().getType().getClassifier())
			return null;
		if(checkForRecursion(SingleEnumComparison_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// MultiEnumComparison
protected class EnumComparison_MultiEnumComparisonParserRuleCall_1 extends RuleCallToken {
	
	public EnumComparison_MultiEnumComparisonParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumComparisonAccess().getMultiEnumComparisonParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultiEnumComparison_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getMultiEnumComparisonRule().getType().getClassifier())
			return null;
		if(checkForRecursion(MultiEnumComparison_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule EnumComparison ****************/


/************ begin Rule SingleEnumComparison ****************
 *
 * SingleEnumComparison:
 * 	ref=Reference "=" eLiteral=[data::EnumLiteral];
 *
 **/

// ref=Reference "=" eLiteral=[data::EnumLiteral]
protected class SingleEnumComparison_Group extends GroupToken {
	
	public SingleEnumComparison_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSingleEnumComparisonAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new SingleEnumComparison_ELiteralAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSingleEnumComparisonRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ref=Reference
protected class SingleEnumComparison_RefAssignment_0 extends AssignmentToken  {
	
	public SingleEnumComparison_RefAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleEnumComparisonAccess().getRefAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Reference_RefAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ref",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ref");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReferenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSingleEnumComparisonAccess().getRefReferenceParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// "="
protected class SingleEnumComparison_EqualsSignKeyword_1 extends KeywordToken  {
	
	public SingleEnumComparison_EqualsSignKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSingleEnumComparisonAccess().getEqualsSignKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new SingleEnumComparison_RefAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// eLiteral=[data::EnumLiteral]
protected class SingleEnumComparison_ELiteralAssignment_2 extends AssignmentToken  {
	
	public SingleEnumComparison_ELiteralAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleEnumComparisonAccess().getELiteralAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new SingleEnumComparison_EqualsSignKeyword_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("eLiteral",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("eLiteral");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSingleEnumComparisonAccess().getELiteralEnumLiteralCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getSingleEnumComparisonAccess().getELiteralEnumLiteralCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule SingleEnumComparison ****************/


/************ begin Rule MultiEnumComparison ****************
 *
 * MultiEnumComparison:
 * 	ref=Reference membership=EnumMembership eLiterals=EnumLiteralsCollection;
 *
 **/

// ref=Reference membership=EnumMembership eLiterals=EnumLiteralsCollection
protected class MultiEnumComparison_Group extends GroupToken {
	
	public MultiEnumComparison_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiEnumComparisonAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultiEnumComparison_ELiteralsAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getMultiEnumComparisonRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ref=Reference
protected class MultiEnumComparison_RefAssignment_0 extends AssignmentToken  {
	
	public MultiEnumComparison_RefAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiEnumComparisonAccess().getRefAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Reference_RefAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ref",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ref");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReferenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getMultiEnumComparisonAccess().getRefReferenceParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// membership=EnumMembership
protected class MultiEnumComparison_MembershipAssignment_1 extends AssignmentToken  {
	
	public MultiEnumComparison_MembershipAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiEnumComparisonAccess().getMembershipAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new MultiEnumComparison_RefAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("membership",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("membership");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getMultiEnumComparisonAccess().getMembershipEnumMembershipEnumRuleCall_1_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getMultiEnumComparisonAccess().getMembershipEnumMembershipEnumRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// eLiterals=EnumLiteralsCollection
protected class MultiEnumComparison_ELiteralsAssignment_2 extends AssignmentToken  {
	
	public MultiEnumComparison_ELiteralsAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiEnumComparisonAccess().getELiteralsAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumLiteralsCollection_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("eLiterals",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("eLiterals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumLiteralsCollectionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getMultiEnumComparisonAccess().getELiteralsEnumLiteralsCollectionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MultiEnumComparison_MembershipAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule MultiEnumComparison ****************/


/************ begin Rule StringValueComparison ****************
 *
 * StringValueComparison:
 * 	ref=Reference "equals" targetValue=STRING;
 *
 **/

// ref=Reference "equals" targetValue=STRING
protected class StringValueComparison_Group extends GroupToken {
	
	public StringValueComparison_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStringValueComparisonAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StringValueComparison_TargetValueAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStringValueComparisonRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ref=Reference
protected class StringValueComparison_RefAssignment_0 extends AssignmentToken  {
	
	public StringValueComparison_RefAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStringValueComparisonAccess().getRefAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Reference_RefAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ref",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ref");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReferenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getStringValueComparisonAccess().getRefReferenceParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// "equals"
protected class StringValueComparison_EqualsKeyword_1 extends KeywordToken  {
	
	public StringValueComparison_EqualsKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStringValueComparisonAccess().getEqualsKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StringValueComparison_RefAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// targetValue=STRING
protected class StringValueComparison_TargetValueAssignment_2 extends AssignmentToken  {
	
	public StringValueComparison_TargetValueAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStringValueComparisonAccess().getTargetValueAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StringValueComparison_EqualsKeyword_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("targetValue",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("targetValue");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getStringValueComparisonAccess().getTargetValueSTRINGTerminalRuleCall_2_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getStringValueComparisonAccess().getTargetValueSTRINGTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule StringValueComparison ****************/


/************ begin Rule PresenceCheck ****************
 *
 * PresenceCheck:
 * 	ref=Reference "is-present";
 *
 **/

// ref=Reference "is-present"
protected class PresenceCheck_Group extends GroupToken {
	
	public PresenceCheck_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPresenceCheckAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PresenceCheck_IsPresentKeyword_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPresenceCheckRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ref=Reference
protected class PresenceCheck_RefAssignment_0 extends AssignmentToken  {
	
	public PresenceCheck_RefAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPresenceCheckAccess().getRefAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Reference_RefAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ref",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ref");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReferenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getPresenceCheckAccess().getRefReferenceParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// "is-present"
protected class PresenceCheck_IsPresentKeyword_1 extends KeywordToken  {
	
	public PresenceCheck_IsPresentKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPresenceCheckAccess().getIsPresentKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PresenceCheck_RefAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule PresenceCheck ****************/


/************ begin Rule EnumLiteralsCollection ****************
 *
 * EnumLiteralsCollection:
 * 	DirectEnumLiteralsCollection | EnumListReference;
 *
 **/

// DirectEnumLiteralsCollection | EnumListReference
protected class EnumLiteralsCollection_Alternatives extends AlternativesToken {

	public EnumLiteralsCollection_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getEnumLiteralsCollectionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumLiteralsCollection_DirectEnumLiteralsCollectionParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new EnumLiteralsCollection_EnumListReferenceParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDirectEnumLiteralsCollectionAccess().getDirectEnumLiteralsCollectionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getEnumListReferenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// DirectEnumLiteralsCollection
protected class EnumLiteralsCollection_DirectEnumLiteralsCollectionParserRuleCall_0 extends RuleCallToken {
	
	public EnumLiteralsCollection_DirectEnumLiteralsCollectionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumLiteralsCollectionAccess().getDirectEnumLiteralsCollectionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DirectEnumLiteralsCollection_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDirectEnumLiteralsCollectionAccess().getDirectEnumLiteralsCollectionAction_0().getType().getClassifier())
			return null;
		if(checkForRecursion(DirectEnumLiteralsCollection_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// EnumListReference
protected class EnumLiteralsCollection_EnumListReferenceParserRuleCall_1 extends RuleCallToken {
	
	public EnumLiteralsCollection_EnumListReferenceParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumLiteralsCollectionAccess().getEnumListReferenceParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new EnumListReference_RefAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEnumListReferenceRule().getType().getClassifier())
			return null;
		if(checkForRecursion(EnumListReference_RefAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule EnumLiteralsCollection ****************/


/************ begin Rule DirectEnumLiteralsCollection ****************
 *
 * DirectEnumLiteralsCollection: // make sure an object is created even if there are no literals, to trigger the validation on enum type
 * 	{DirectEnumLiteralsCollection} "(" literals+=[data::EnumLiteral]* ")";
 *
 **/

// // make sure an object is created even if there are no literals, to trigger the validation on enum type
// {DirectEnumLiteralsCollection} "(" literals+=[data::EnumLiteral]* ")"
protected class DirectEnumLiteralsCollection_Group extends GroupToken {
	
	public DirectEnumLiteralsCollection_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDirectEnumLiteralsCollectionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DirectEnumLiteralsCollection_RightParenthesisKeyword_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDirectEnumLiteralsCollectionAccess().getDirectEnumLiteralsCollectionAction_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// // make sure an object is created even if there are no literals, to trigger the validation on enum type
// {DirectEnumLiteralsCollection}
protected class DirectEnumLiteralsCollection_DirectEnumLiteralsCollectionAction_0 extends ActionToken  {

	public DirectEnumLiteralsCollection_DirectEnumLiteralsCollectionAction_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getDirectEnumLiteralsCollectionAccess().getDirectEnumLiteralsCollectionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(!eObjectConsumer.isConsumed()) return null;
		return eObjectConsumer;
	}
}

// "("
protected class DirectEnumLiteralsCollection_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public DirectEnumLiteralsCollection_LeftParenthesisKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDirectEnumLiteralsCollectionAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DirectEnumLiteralsCollection_DirectEnumLiteralsCollectionAction_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// literals+=[data::EnumLiteral]*
protected class DirectEnumLiteralsCollection_LiteralsAssignment_2 extends AssignmentToken  {
	
	public DirectEnumLiteralsCollection_LiteralsAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDirectEnumLiteralsCollectionAccess().getLiteralsAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DirectEnumLiteralsCollection_LiteralsAssignment_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new DirectEnumLiteralsCollection_LeftParenthesisKeyword_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("literals",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("literals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDirectEnumLiteralsCollectionAccess().getLiteralsEnumLiteralCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getDirectEnumLiteralsCollectionAccess().getLiteralsEnumLiteralCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ")"
protected class DirectEnumLiteralsCollection_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public DirectEnumLiteralsCollection_RightParenthesisKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDirectEnumLiteralsCollectionAccess().getRightParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new DirectEnumLiteralsCollection_LiteralsAssignment_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new DirectEnumLiteralsCollection_LeftParenthesisKeyword_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}


/************ end Rule DirectEnumLiteralsCollection ****************/


/************ begin Rule EnumListReference ****************
 *
 * / * scoping:
 *      * literals must be owned by the data::Enumeration pointed to by the
 *      *  resolution of the (field|alias).path of the containing AtomicReferringBExpression
 *      * validation:
 *      * Empty lists are allowed but flagged with a warning.
 *      * // * scoping:
 *      * ref.enum must equal the data::Enumeration resolved to by (field|alias).path
 *      *  of the containing AtomicReferringBExpression
 *      * /EnumListReference:
 * 	ref=[EnumList];
 *
 **/

// ref=[EnumList]
protected class EnumListReference_RefAssignment extends AssignmentToken  {
	
	public EnumListReference_RefAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumListReferenceAccess().getRefAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getEnumListReferenceRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("ref",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ref");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumListReferenceAccess().getRefEnumListCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getEnumListReferenceAccess().getRefEnumListCrossReference_0(); 
				return obj;
			}
		}
		return null;
	}

}

/************ end Rule EnumListReference ****************/

}
