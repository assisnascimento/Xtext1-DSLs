/*
* generated by Xtext
*/

package nl.dslmeinte.xtext.examples.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class DynamicScreenDslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class DynamicScreenElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DynamicScreen");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDynamicScreenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLabelLabelParserRuleCall_1_0 = (RuleCall)cLabelAssignment_1.eContents().get(0);
		private final Keyword cDataImportKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cImportURIAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cImportURISTRINGTerminalRuleCall_4_0 = (RuleCall)cImportURIAssignment_4.eContents().get(0);
		private final Keyword cViewClassKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cEqualsSignKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cViewClassAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final CrossReference cViewClassEntityCrossReference_7_0 = (CrossReference)cViewClassAssignment_7.eContents().get(0);
		private final RuleCall cViewClassEntityIDTerminalRuleCall_7_0_1 = (RuleCall)cViewClassEntityCrossReference_7_0.eContents().get(1);
		private final Assignment cDeclarationsAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cDeclarationsDeclarationParserRuleCall_8_0 = (RuleCall)cDeclarationsAssignment_8.eContents().get(0);
		private final Assignment cGroupsAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cGroupsFieldGroupParserRuleCall_9_0 = (RuleCall)cGroupsAssignment_9.eContents().get(0);
		
		/// *
		// * An instance of this DSL describes a screen with a lot of custom
		// * dynamism (and structure) on it. The dynamism supported in the
		// * language are:
		// * 
		// *  - fields are visible, mandatory (required), readonly or not
		// *      depending on the values of other fields
		// *  - selection list (of enums) are restricted depending on the
		// *      values of other fields
		// *
		// * Aspects and features still TODO (roughly in order of priority):
		// *
		// *  1) add paths relative to data stores for non-enum selection lists
		// *  2) short hand for commonly used boolean expressions
		// *  3) sample population of fields (especially useful for data stores @1)
		// * // *
		// * +-----------------------------+
		// * | Infrastructure and generics |
		// * +-----------------------------+
		// * /DynamicScreen:
		//	"dynamic-screen" label=Label "data-import" "=" importURI=STRING "view-class" "=" viewClass=[data::Entity]
		//	declarations+=Declaration* groups+=FieldGroup+;
		public ParserRule getRule() { return rule; }

		//"dynamic-screen" label=Label "data-import" "=" importURI=STRING "view-class" "=" viewClass=[data::Entity]
		//declarations+=Declaration* groups+=FieldGroup+
		public Group getGroup() { return cGroup; }

		//"dynamic-screen"
		public Keyword getDynamicScreenKeyword_0() { return cDynamicScreenKeyword_0; }

		//label=Label
		public Assignment getLabelAssignment_1() { return cLabelAssignment_1; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0() { return cLabelLabelParserRuleCall_1_0; }

		//"data-import"
		public Keyword getDataImportKeyword_2() { return cDataImportKeyword_2; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//importURI=STRING
		public Assignment getImportURIAssignment_4() { return cImportURIAssignment_4; }

		//STRING
		public RuleCall getImportURISTRINGTerminalRuleCall_4_0() { return cImportURISTRINGTerminalRuleCall_4_0; }

		//"view-class"
		public Keyword getViewClassKeyword_5() { return cViewClassKeyword_5; }

		//"="
		public Keyword getEqualsSignKeyword_6() { return cEqualsSignKeyword_6; }

		//viewClass=[data::Entity]
		public Assignment getViewClassAssignment_7() { return cViewClassAssignment_7; }

		//[data::Entity]
		public CrossReference getViewClassEntityCrossReference_7_0() { return cViewClassEntityCrossReference_7_0; }

		//ID
		public RuleCall getViewClassEntityIDTerminalRuleCall_7_0_1() { return cViewClassEntityIDTerminalRuleCall_7_0_1; }

		//declarations+=Declaration*
		public Assignment getDeclarationsAssignment_8() { return cDeclarationsAssignment_8; }

		//Declaration
		public RuleCall getDeclarationsDeclarationParserRuleCall_8_0() { return cDeclarationsDeclarationParserRuleCall_8_0; }

		//groups+=FieldGroup+
		public Assignment getGroupsAssignment_9() { return cGroupsAssignment_9; }

		//FieldGroup
		public RuleCall getGroupsFieldGroupParserRuleCall_9_0() { return cGroupsFieldGroupParserRuleCall_9_0; }
	}

	public class LabelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Label");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEnAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cEnSTRINGTerminalRuleCall_0_0 = (RuleCall)cEnAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cNlKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNlAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNlSTRINGTerminalRuleCall_1_1_0 = (RuleCall)cNlAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//Label:
		//	en=STRING ("[nl:" nl=STRING "]")?;
		public ParserRule getRule() { return rule; }

		//en=STRING ("[nl:" nl=STRING "]")?
		public Group getGroup() { return cGroup; }

		//en=STRING
		public Assignment getEnAssignment_0() { return cEnAssignment_0; }

		//STRING
		public RuleCall getEnSTRINGTerminalRuleCall_0_0() { return cEnSTRINGTerminalRuleCall_0_0; }

		//("[nl:" nl=STRING "]")?
		public Group getGroup_1() { return cGroup_1; }

		//"[nl:"
		public Keyword getNlKeyword_1_0() { return cNlKeyword_1_0; }

		//nl=STRING
		public Assignment getNlAssignment_1_1() { return cNlAssignment_1_1; }

		//STRING
		public RuleCall getNlSTRINGTerminalRuleCall_1_1_0() { return cNlSTRINGTerminalRuleCall_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}

	public class PathTailElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PathTail");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSolidusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFieldAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cFieldFieldCrossReference_1_0 = (CrossReference)cFieldAssignment_1.eContents().get(0);
		private final RuleCall cFieldFieldIDTerminalRuleCall_1_0_1 = (RuleCall)cFieldFieldCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cAsEntityAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cAsEntityEntityCrossReference_2_1_0 = (CrossReference)cAsEntityAssignment_2_1.eContents().get(0);
		private final RuleCall cAsEntityEntityIDTerminalRuleCall_2_1_0_1 = (RuleCall)cAsEntityEntityCrossReference_2_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cTailAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTailPathTailParserRuleCall_3_0 = (RuleCall)cTailAssignment_3.eContents().get(0);
		
		//PathTail:
		//	"/" field=[data::Field] ("(" asEntity=[data::Entity] ")")? tail=PathTail?;
		public ParserRule getRule() { return rule; }

		//"/" field=[data::Field] ("(" asEntity=[data::Entity] ")")? tail=PathTail?
		public Group getGroup() { return cGroup; }

		//"/"
		public Keyword getSolidusKeyword_0() { return cSolidusKeyword_0; }

		//field=[data::Field]
		public Assignment getFieldAssignment_1() { return cFieldAssignment_1; }

		//[data::Field]
		public CrossReference getFieldFieldCrossReference_1_0() { return cFieldFieldCrossReference_1_0; }

		//ID
		public RuleCall getFieldFieldIDTerminalRuleCall_1_0_1() { return cFieldFieldIDTerminalRuleCall_1_0_1; }

		//("(" asEntity=[data::Entity] ")")?
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//asEntity=[data::Entity]
		public Assignment getAsEntityAssignment_2_1() { return cAsEntityAssignment_2_1; }

		//[data::Entity]
		public CrossReference getAsEntityEntityCrossReference_2_1_0() { return cAsEntityEntityCrossReference_2_1_0; }

		//ID
		public RuleCall getAsEntityEntityIDTerminalRuleCall_2_1_0_1() { return cAsEntityEntityIDTerminalRuleCall_2_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }

		//tail=PathTail?
		public Assignment getTailAssignment_3() { return cTailAssignment_3; }

		//PathTail
		public RuleCall getTailPathTailParserRuleCall_3_0() { return cTailPathTailParserRuleCall_3_0; }
	}

	public class DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExternalVariableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnumListParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDataStoreParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * scoping:
		//     * if asEntity is present, then:
		//     *  1) the type of element must be an entity,
		//     *  2) asEntity must be a proper sub entity of the type of element.
		//     * // *
		//DataStorePathHead:
		//    '[' dataStore=[DataStore] ']' tail=PathTail
		//    ;
		// * // *
		// * +--------------+
		// * | Declarations |
		// * +--------------+
		// * /// TODO  give aliases, enumeration list definitions and conditions their own segment ('aliases:', &c)
		////          as soon as the current format turns out to be unwieldy (saves some filtering as well)
		//Declaration:
		//	ExternalVariable | EnumList | DataStore;
		public ParserRule getRule() { return rule; }

		//ExternalVariable | EnumList | DataStore
		public Alternatives getAlternatives() { return cAlternatives; }

		//ExternalVariable
		public RuleCall getExternalVariableParserRuleCall_0() { return cExternalVariableParserRuleCall_0; }

		//EnumList
		public RuleCall getEnumListParserRuleCall_1() { return cEnumListParserRuleCall_1; }

		//DataStore
		public RuleCall getDataStoreParserRuleCall_2() { return cDataStoreParserRuleCall_2; }
	}

	public class ExternalVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExternalVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExternalVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPathAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPathPathTailParserRuleCall_1_0 = (RuleCall)cPathAssignment_1.eContents().get(0);
		private final Keyword cAsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		
		//// alias to path inside declared view class
		//// (may only be static and not be present on the screen)
		//ExternalVariable:
		//	"external-var" path=PathTail "as" name=ID;
		public ParserRule getRule() { return rule; }

		//"external-var" path=PathTail "as" name=ID
		public Group getGroup() { return cGroup; }

		//"external-var"
		public Keyword getExternalVarKeyword_0() { return cExternalVarKeyword_0; }

		//path=PathTail
		public Assignment getPathAssignment_1() { return cPathAssignment_1; }

		//PathTail
		public RuleCall getPathPathTailParserRuleCall_1_0() { return cPathPathTailParserRuleCall_1_0; }

		//"as"
		public Keyword getAsKeyword_2() { return cAsKeyword_2; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }
	}

	public class EnumListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cAsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cLiteralsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cLiteralsEnumLiteralCrossReference_4_0 = (CrossReference)cLiteralsAssignment_4.eContents().get(0);
		private final RuleCall cLiteralsEnumLiteralIDTerminalRuleCall_4_0_1 = (RuleCall)cLiteralsEnumLiteralCrossReference_4_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cOfKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cEnumAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final CrossReference cEnumEnumerationCrossReference_7_0 = (CrossReference)cEnumAssignment_7.eContents().get(0);
		private final RuleCall cEnumEnumerationIDTerminalRuleCall_7_0_1 = (RuleCall)cEnumEnumerationCrossReference_7_0.eContents().get(1);
		
		//EnumList:
		//	"define" name=ID "as" "(" literals+=[data::EnumLiteral]+ ")" "of" ^enum=[data::Enumeration];
		public ParserRule getRule() { return rule; }

		//"define" name=ID "as" "(" literals+=[data::EnumLiteral]+ ")" "of" ^enum=[data::Enumeration]
		public Group getGroup() { return cGroup; }

		//"define"
		public Keyword getDefineKeyword_0() { return cDefineKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"as"
		public Keyword getAsKeyword_2() { return cAsKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//literals+=[data::EnumLiteral]+
		public Assignment getLiteralsAssignment_4() { return cLiteralsAssignment_4; }

		//[data::EnumLiteral]
		public CrossReference getLiteralsEnumLiteralCrossReference_4_0() { return cLiteralsEnumLiteralCrossReference_4_0; }

		//ID
		public RuleCall getLiteralsEnumLiteralIDTerminalRuleCall_4_0_1() { return cLiteralsEnumLiteralIDTerminalRuleCall_4_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//"of"
		public Keyword getOfKeyword_6() { return cOfKeyword_6; }

		//^enum=[data::Enumeration]
		public Assignment getEnumAssignment_7() { return cEnumAssignment_7; }

		//[data::Enumeration]
		public CrossReference getEnumEnumerationCrossReference_7_0() { return cEnumEnumerationCrossReference_7_0; }

		//ID
		public RuleCall getEnumEnumerationIDTerminalRuleCall_7_0_1() { return cEnumEnumerationIDTerminalRuleCall_7_0_1; }
	}

	public class DataStoreElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DataStore");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDataStoreKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cOfTypeKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cClassAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cClassEntityCrossReference_3_0 = (CrossReference)cClassAssignment_3.eContents().get(0);
		private final RuleCall cClassEntityIDTerminalRuleCall_3_0_1 = (RuleCall)cClassEntityCrossReference_3_0.eContents().get(1);
		private final Assignment cMultiAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cMultiIsMultiValuedKeyword_4_0 = (Keyword)cMultiAssignment_4.eContents().get(0);
		
		/// * scoping:
		//     * all literals must be a member of that resolved data::Enumeration
		//     * /DataStore:
		//	"data-store" name=ID "of-type" class=[data::Entity] multi?="is-multi-valued"?;
		public ParserRule getRule() { return rule; }

		//"data-store" name=ID "of-type" class=[data::Entity] multi?="is-multi-valued"?
		public Group getGroup() { return cGroup; }

		//"data-store"
		public Keyword getDataStoreKeyword_0() { return cDataStoreKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"of-type"
		public Keyword getOfTypeKeyword_2() { return cOfTypeKeyword_2; }

		//class=[data::Entity]
		public Assignment getClassAssignment_3() { return cClassAssignment_3; }

		//[data::Entity]
		public CrossReference getClassEntityCrossReference_3_0() { return cClassEntityCrossReference_3_0; }

		//ID
		public RuleCall getClassEntityIDTerminalRuleCall_3_0_1() { return cClassEntityIDTerminalRuleCall_3_0_1; }

		//multi?="is-multi-valued"?
		public Assignment getMultiAssignment_4() { return cMultiAssignment_4; }

		//"is-multi-valued"
		public Keyword getMultiIsMultiValuedKeyword_4_0() { return cMultiIsMultiValuedKeyword_4_0; }
	}

	public class GroupElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroupElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFieldParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFieldGroupParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		// * +------------------+
		// * | Screen structure |
		// * +------------------+
		// * /GroupElement:
		//	Field | FieldGroup;
		public ParserRule getRule() { return rule; }

		//Field | FieldGroup
		public Alternatives getAlternatives() { return cAlternatives; }

		//Field
		public RuleCall getFieldParserRuleCall_0() { return cFieldParserRuleCall_0; }

		//FieldGroup
		public RuleCall getFieldGroupParserRuleCall_1() { return cFieldGroupParserRuleCall_1; }
	}

	public class FieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Field");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cLabelAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLabelLabelParserRuleCall_1_0 = (RuleCall)cLabelAssignment_1.eContents().get(0);
		private final Assignment cPathAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPathPathTailParserRuleCall_2_0 = (RuleCall)cPathAssignment_2.eContents().get(0);
		private final Assignment cAttributesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAttributesAttributeParserRuleCall_3_0 = (RuleCall)cAttributesAssignment_3.eContents().get(0);
		
		//Field:
		//	name=ID label=Label path=PathTail attributes+=Attribute*;
		public ParserRule getRule() { return rule; }

		//name=ID label=Label path=PathTail attributes+=Attribute*
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//label=Label
		public Assignment getLabelAssignment_1() { return cLabelAssignment_1; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0() { return cLabelLabelParserRuleCall_1_0; }

		//path=PathTail
		public Assignment getPathAssignment_2() { return cPathAssignment_2; }

		//PathTail
		public RuleCall getPathPathTailParserRuleCall_2_0() { return cPathPathTailParserRuleCall_2_0; }

		//attributes+=Attribute*
		public Assignment getAttributesAssignment_3() { return cAttributesAssignment_3; }

		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_3_0() { return cAttributesAttributeParserRuleCall_3_0; }
	}

	public class FieldGroupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FieldGroup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGroupKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLabelAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLabelLabelParserRuleCall_1_0 = (RuleCall)cLabelAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cWithKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cWithAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cWithPathTailParserRuleCall_2_1_0 = (RuleCall)cWithAssignment_2_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cElementsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElementsGroupElementParserRuleCall_4_0 = (RuleCall)cElementsAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cAttributesAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cAttributesAttributeParserRuleCall_6_0 = (RuleCall)cAttributesAssignment_6.eContents().get(0);
		
		//FieldGroup:
		//	"group" label=Label? ("with" ^with=PathTail)? "{" elements+=GroupElement+ "}" attributes+=Attribute*;
		public ParserRule getRule() { return rule; }

		//"group" label=Label? ("with" ^with=PathTail)? "{" elements+=GroupElement+ "}" attributes+=Attribute*
		public Group getGroup() { return cGroup; }

		//"group"
		public Keyword getGroupKeyword_0() { return cGroupKeyword_0; }

		//label=Label?
		public Assignment getLabelAssignment_1() { return cLabelAssignment_1; }

		//Label
		public RuleCall getLabelLabelParserRuleCall_1_0() { return cLabelLabelParserRuleCall_1_0; }

		//("with" ^with=PathTail)?
		public Group getGroup_2() { return cGroup_2; }

		//"with"
		public Keyword getWithKeyword_2_0() { return cWithKeyword_2_0; }

		//^with=PathTail
		public Assignment getWithAssignment_2_1() { return cWithAssignment_2_1; }

		//PathTail
		public RuleCall getWithPathTailParserRuleCall_2_1_0() { return cWithPathTailParserRuleCall_2_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//elements+=GroupElement+
		public Assignment getElementsAssignment_4() { return cElementsAssignment_4; }

		//GroupElement
		public RuleCall getElementsGroupElementParserRuleCall_4_0() { return cElementsGroupElementParserRuleCall_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }

		//attributes+=Attribute*
		public Assignment getAttributesAssignment_6() { return cAttributesAssignment_6; }

		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_6_0() { return cAttributesAttributeParserRuleCall_6_0; }
	}

	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Attribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNormalAttributeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnumFieldAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// * semantics:
		//     * The paths inside (anywhere) within this group are considered relative
		//     *  to the 'with' path (which itself may be relative to some group instead
		//     *  of the declared view class). Note that the semantics of Field.path
		//     *  also change to be relative.
		//     * The attributes declared at group-level can be overridden at the field-level.
		//     * // * validations:
		//     * For top-level groups, a label is required.
		//     * // *
		// * +------------------+
		// * | Field attributes |
		// * +------------------+
		// * /Attribute:
		//	NormalAttribute | EnumFieldAttribute;
		public ParserRule getRule() { return rule; }

		//NormalAttribute | EnumFieldAttribute
		public Alternatives getAlternatives() { return cAlternatives; }

		//NormalAttribute
		public RuleCall getNormalAttributeParserRuleCall_0() { return cNormalAttributeParserRuleCall_0; }

		//EnumFieldAttribute
		public RuleCall getEnumFieldAttributeParserRuleCall_1() { return cEnumFieldAttributeParserRuleCall_1; }
	}

	public class EnumFieldAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumFieldAttribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRestrictionAttributeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRestrictionGroupAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EnumFieldAttribute:
		//	RestrictionAttribute | RestrictionGroupAttribute;
		public ParserRule getRule() { return rule; }

		//RestrictionAttribute | RestrictionGroupAttribute
		public Alternatives getAlternatives() { return cAlternatives; }

		//RestrictionAttribute
		public RuleCall getRestrictionAttributeParserRuleCall_0() { return cRestrictionAttributeParserRuleCall_0; }

		//RestrictionGroupAttribute
		public RuleCall getRestrictionGroupAttributeParserRuleCall_1() { return cRestrictionGroupAttributeParserRuleCall_1; }
	}

	public class NormalAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NormalAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cClassExprAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cClassExprAttributeClassExpressionParserRuleCall_0_0 = (RuleCall)cClassExprAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cIfKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cClauseAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cClauseBExpressionParserRuleCall_1_1_0 = (RuleCall)cClauseAssignment_1_1.eContents().get(0);
		
		//NormalAttribute:
		//	classExpr=AttributeClassExpression ("if" clause=BExpression)?;
		public ParserRule getRule() { return rule; }

		//classExpr=AttributeClassExpression ("if" clause=BExpression)?
		public Group getGroup() { return cGroup; }

		//classExpr=AttributeClassExpression
		public Assignment getClassExprAssignment_0() { return cClassExprAssignment_0; }

		//AttributeClassExpression
		public RuleCall getClassExprAttributeClassExpressionParserRuleCall_0_0() { return cClassExprAttributeClassExpressionParserRuleCall_0_0; }

		//("if" clause=BExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//"if"
		public Keyword getIfKeyword_1_0() { return cIfKeyword_1_0; }

		//clause=BExpression
		public Assignment getClauseAssignment_1_1() { return cClauseAssignment_1_1; }

		//BExpression
		public RuleCall getClauseBExpressionParserRuleCall_1_1_0() { return cClauseBExpressionParserRuleCall_1_1_0; }
	}

	public class AttributeClassExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeClassExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cClassesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cClassesAttributeClassEnumRuleCall_0_0 = (RuleCall)cClassesAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cClassesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cClassesAttributeClassEnumRuleCall_1_1_0 = (RuleCall)cClassesAssignment_1_1.eContents().get(0);
		
		/// * semantics:
		//     * 'if' means 'if and only if' (i.e., 'iff').
		//     * /AttributeClassExpression:
		//	classes+=AttributeClass ("+" classes+=AttributeClass)*;
		public ParserRule getRule() { return rule; }

		//classes+=AttributeClass ("+" classes+=AttributeClass)*
		public Group getGroup() { return cGroup; }

		//classes+=AttributeClass
		public Assignment getClassesAssignment_0() { return cClassesAssignment_0; }

		//AttributeClass
		public RuleCall getClassesAttributeClassEnumRuleCall_0_0() { return cClassesAttributeClassEnumRuleCall_0_0; }

		//("+" classes+=AttributeClass)*
		public Group getGroup_1() { return cGroup_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_0() { return cPlusSignKeyword_1_0; }

		//classes+=AttributeClass
		public Assignment getClassesAssignment_1_1() { return cClassesAssignment_1_1; }

		//AttributeClass
		public RuleCall getClassesAttributeClassEnumRuleCall_1_1_0() { return cClassesAttributeClassEnumRuleCall_1_1_0; }
	}

	public class RestrictionAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RestrictionAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRestrictToKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLiteralsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLiteralsEnumLiteralsCollectionParserRuleCall_1_0 = (RuleCall)cLiteralsAssignment_1.eContents().get(0);
		private final Keyword cIfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cClauseAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cClauseBExpressionParserRuleCall_3_0 = (RuleCall)cClauseAssignment_3.eContents().get(0);
		
		//RestrictionAttribute:
		//	"restrict-to" literals=EnumLiteralsCollection "if" clause=BExpression;
		public ParserRule getRule() { return rule; }

		//"restrict-to" literals=EnumLiteralsCollection "if" clause=BExpression
		public Group getGroup() { return cGroup; }

		//"restrict-to"
		public Keyword getRestrictToKeyword_0() { return cRestrictToKeyword_0; }

		//literals=EnumLiteralsCollection
		public Assignment getLiteralsAssignment_1() { return cLiteralsAssignment_1; }

		//EnumLiteralsCollection
		public RuleCall getLiteralsEnumLiteralsCollectionParserRuleCall_1_0() { return cLiteralsEnumLiteralsCollectionParserRuleCall_1_0; }

		//"if"
		public Keyword getIfKeyword_2() { return cIfKeyword_2; }

		//clause=BExpression
		public Assignment getClauseAssignment_3() { return cClauseAssignment_3; }

		//BExpression
		public RuleCall getClauseBExpressionParserRuleCall_3_0() { return cClauseBExpressionParserRuleCall_3_0; }
	}

	public class RestrictionGroupAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RestrictionGroupAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRestrictionGroupAttributeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRestrictToGroupKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLessThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRulesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRulesRestrictionRuleParserRuleCall_3_0 = (RuleCall)cRulesAssignment_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// * validation:
		//     * Can only be used if the (enclosing) field has a data::Enumeration as type.
		//     * scoping:
		//     * The literals must be owned by the Enumeration type of the (enclosing) field.
		//     * semantics:
		//     * If the clause expression evaluates to true, the possible values for the (enclosing)
		//     * Enumeration field should be restricted to the given list.
		//     * TODO  what to do with overlap in the clauses? evaluation in order?
		//     * /RestrictionGroupAttribute: // make sure an object is created even with no rules, to trigger the validation on enum type
		//	{RestrictionGroupAttribute} "restrict-to-group" "<" rules+=RestrictionRule+ ">";
		public ParserRule getRule() { return rule; }

		//// make sure an object is created even with no rules, to trigger the validation on enum type
		//{RestrictionGroupAttribute} "restrict-to-group" "<" rules+=RestrictionRule+ ">"
		public Group getGroup() { return cGroup; }

		//// make sure an object is created even with no rules, to trigger the validation on enum type
		//{RestrictionGroupAttribute}
		public Action getRestrictionGroupAttributeAction_0() { return cRestrictionGroupAttributeAction_0; }

		//"restrict-to-group"
		public Keyword getRestrictToGroupKeyword_1() { return cRestrictToGroupKeyword_1; }

		//"<"
		public Keyword getLessThanSignKeyword_2() { return cLessThanSignKeyword_2; }

		//rules+=RestrictionRule+
		public Assignment getRulesAssignment_3() { return cRulesAssignment_3; }

		//RestrictionRule
		public RuleCall getRulesRestrictionRuleParserRuleCall_3_0() { return cRulesRestrictionRuleParserRuleCall_3_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_4() { return cGreaterThanSignKeyword_4; }
	}

	public class RestrictionRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RestrictionRule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLiteralsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLiteralsEnumLiteralsCollectionParserRuleCall_0_0 = (RuleCall)cLiteralsAssignment_0.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cClauseAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cClauseBExpressionParserRuleCall_2_0 = (RuleCall)cClauseAssignment_2.eContents().get(0);
		
		//RestrictionRule:
		//	literals=EnumLiteralsCollection "if" clause=BExpression;
		public ParserRule getRule() { return rule; }

		//literals=EnumLiteralsCollection "if" clause=BExpression
		public Group getGroup() { return cGroup; }

		//literals=EnumLiteralsCollection
		public Assignment getLiteralsAssignment_0() { return cLiteralsAssignment_0; }

		//EnumLiteralsCollection
		public RuleCall getLiteralsEnumLiteralsCollectionParserRuleCall_0_0() { return cLiteralsEnumLiteralsCollectionParserRuleCall_0_0; }

		//"if"
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }

		//clause=BExpression
		public Assignment getClauseAssignment_2() { return cClauseAssignment_2; }

		//BExpression
		public RuleCall getClauseBExpressionParserRuleCall_2_0() { return cClauseBExpressionParserRuleCall_2_0; }
	}

	public class ReferenceTargetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReferenceTarget");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFieldParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExternalVariableParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// * scoping:
		//     * Same as (and already taken of by scoping implementation) for RestrictionAttribute.literals
		//     * // *
		// * +------------+
		// * | References |
		// * +------------+
		// * /ReferenceTarget:
		//	Field | ExternalVariable;
		public ParserRule getRule() { return rule; }

		//Field | ExternalVariable
		public Alternatives getAlternatives() { return cAlternatives; }

		//Field
		public RuleCall getFieldParserRuleCall_0() { return cFieldParserRuleCall_0; }

		//ExternalVariable
		public RuleCall getExternalVariableParserRuleCall_1() { return cExternalVariableParserRuleCall_1; }
	}

	public class ReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Reference");
		private final Assignment cRefAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cRefReferenceTargetCrossReference_0 = (CrossReference)cRefAssignment.eContents().get(0);
		private final RuleCall cRefReferenceTargetIDTerminalRuleCall_0_1 = (RuleCall)cRefReferenceTargetCrossReference_0.eContents().get(1);
		
		//Reference:
		//	ref=[ReferenceTarget];
		public ParserRule getRule() { return rule; }

		//ref=[ReferenceTarget]
		public Assignment getRefAssignment() { return cRefAssignment; }

		//[ReferenceTarget]
		public CrossReference getRefReferenceTargetCrossReference_0() { return cRefReferenceTargetCrossReference_0; }

		//ID
		public RuleCall getRefReferenceTargetIDTerminalRuleCall_0_1() { return cRefReferenceTargetIDTerminalRuleCall_0_1; }
	}

	public class DummyForExternalVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DummyForExternalVariable");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cReferenceTargetParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		// * This dummy type rule is needed because of the 'pull features up' transformation
		// * of the Ecore models generated from Xtext grammars. Without this, the Ecore ends up
		// * with the following elements:
		// *
		// * Declaration: name(ID)
		// * ReferenceTarget: name(ID) (, path)
		// * ExternalVariable -> Declaration, ReferenceTarget
		// *
		// * This would lead to duplicate generation of a field 'ALIAS__NAME' in DynamismDslPackage.
		// * /DummyForExternalVariable:
		//	Declaration | ReferenceTarget;
		public ParserRule getRule() { return rule; }

		//Declaration | ReferenceTarget
		public Alternatives getAlternatives() { return cAlternatives; }

		//Declaration
		public RuleCall getDeclarationParserRuleCall_0() { return cDeclarationParserRuleCall_0; }

		//ReferenceTarget
		public RuleCall getReferenceTargetParserRuleCall_1() { return cReferenceTargetParserRuleCall_1; }
	}

	public class BExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BExpression");
		private final RuleCall cBOrExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// *
		// * +---------------------+
		// * | Boolean expressions |
		// * +---------------------+
		// *
		// * Note: in the following, a solitary 'B' within a camel-cased word
		// * always serves as an abbreviation of 'Boolean'.
		// *
		// * FIXME  grammar ambiguity, due to the fact that operator precedence currently doesn't behave nicely
		// * TODO   rewrite expression grammar to conform with Best Practices (for now: leave as is...)
		// * /// boolean expression tree-building:
		//BExpression:
		//	BOrExpression;
		public ParserRule getRule() { return rule; }

		//BOrExpression
		public RuleCall getBOrExpressionParserRuleCall() { return cBOrExpressionParserRuleCall; }
	}

	public class BOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrOperationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cOrKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//BOrExpression returns BExpression:
		//	BAndExpression ({OrOperation.left=current} ("or" | "|") right=BAndExpression)*;
		public ParserRule getRule() { return rule; }

		//BAndExpression ({OrOperation.left=current} ("or" | "|") right=BAndExpression)*
		public Group getGroup() { return cGroup; }

		//BAndExpression
		public RuleCall getBAndExpressionParserRuleCall_0() { return cBAndExpressionParserRuleCall_0; }

		//({OrOperation.left=current} ("or" | "|") right=BAndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{OrOperation.left=current}
		public Action getOrOperationLeftAction_1_0() { return cOrOperationLeftAction_1_0; }

		//"or" | "|"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"or"
		public Keyword getOrKeyword_1_1_0() { return cOrKeyword_1_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_1_1_1() { return cVerticalLineKeyword_1_1_1; }

		//right=BAndExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//BAndExpression
		public RuleCall getRightBAndExpressionParserRuleCall_1_2_0() { return cRightBAndExpressionParserRuleCall_1_2_0; }
	}

	public class BAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNegationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndOperationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cAndKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cAmpersandKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightNegationExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//BAndExpression returns BExpression:
		//	NegationExpression ({AndOperation.left=current} ("and" | "&") right=NegationExpression)*;
		public ParserRule getRule() { return rule; }

		//NegationExpression ({AndOperation.left=current} ("and" | "&") right=NegationExpression)*
		public Group getGroup() { return cGroup; }

		//NegationExpression
		public RuleCall getNegationExpressionParserRuleCall_0() { return cNegationExpressionParserRuleCall_0; }

		//({AndOperation.left=current} ("and" | "&") right=NegationExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{AndOperation.left=current}
		public Action getAndOperationLeftAction_1_0() { return cAndOperationLeftAction_1_0; }

		//"and" | "&"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"and"
		public Keyword getAndKeyword_1_1_0() { return cAndKeyword_1_1_0; }

		//"&"
		public Keyword getAmpersandKeyword_1_1_1() { return cAmpersandKeyword_1_1_1; }

		//right=NegationExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//NegationExpression
		public RuleCall getRightNegationExpressionParserRuleCall_1_2_0() { return cRightNegationExpressionParserRuleCall_1_2_0; }
	}

	public class NegationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NegationExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTerminalBExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNegationExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cNotKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExprNegationExpressionParserRuleCall_1_2_0 = (RuleCall)cExprAssignment_1_2.eContents().get(0);
		
		//NegationExpression returns BExpression:
		//	TerminalBExpression | {NegationExpression} ("not" | "!") expr=NegationExpression;
		public ParserRule getRule() { return rule; }

		//TerminalBExpression | {NegationExpression} ("not" | "!") expr=NegationExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//TerminalBExpression
		public RuleCall getTerminalBExpressionParserRuleCall_0() { return cTerminalBExpressionParserRuleCall_0; }

		//{NegationExpression} ("not" | "!") expr=NegationExpression
		public Group getGroup_1() { return cGroup_1; }

		//{NegationExpression}
		public Action getNegationExpressionAction_1_0() { return cNegationExpressionAction_1_0; }

		//"not" | "!"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"not"
		public Keyword getNotKeyword_1_1_0() { return cNotKeyword_1_1_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_1_1() { return cExclamationMarkKeyword_1_1_1; }

		//expr=NegationExpression
		public Assignment getExprAssignment_1_2() { return cExprAssignment_1_2; }

		//NegationExpression
		public RuleCall getExprNegationExpressionParserRuleCall_1_2_0() { return cExprNegationExpressionParserRuleCall_1_2_0; }
	}

	public class TerminalBExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TerminalBExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomicReferringBExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cBExpressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//TerminalBExpression returns BExpression:
		//	AtomicReferringBExpression | "(" BExpression ")";
		public ParserRule getRule() { return rule; }

		//AtomicReferringBExpression | "(" BExpression ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//AtomicReferringBExpression
		public RuleCall getAtomicReferringBExpressionParserRuleCall_0() { return cAtomicReferringBExpressionParserRuleCall_0; }

		//"(" BExpression ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//BExpression
		public RuleCall getBExpressionParserRuleCall_1_1() { return cBExpressionParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class AtomicReferringBExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomicReferringBExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBComparisonParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnumComparisonParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cStringValueComparisonParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPresenceCheckParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//AtomicReferringBExpression:
		//	BComparison | EnumComparison | StringValueComparison | PresenceCheck;
		public ParserRule getRule() { return rule; }

		//BComparison | EnumComparison | StringValueComparison | PresenceCheck
		public Alternatives getAlternatives() { return cAlternatives; }

		//BComparison
		public RuleCall getBComparisonParserRuleCall_0() { return cBComparisonParserRuleCall_0; }

		//EnumComparison
		public RuleCall getEnumComparisonParserRuleCall_1() { return cEnumComparisonParserRuleCall_1; }

		//StringValueComparison
		public RuleCall getStringValueComparisonParserRuleCall_2() { return cStringValueComparisonParserRuleCall_2; }

		//PresenceCheck
		public RuleCall getPresenceCheckParserRuleCall_3() { return cPresenceCheckParserRuleCall_3; }
	}

	public class BComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BComparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBComparisonAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cRefAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRefReferenceParserRuleCall_1_0 = (RuleCall)cRefAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cIsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cBLiteralAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cBLiteralBLiteralEnumRuleCall_2_1_0 = (RuleCall)cBLiteralAssignment_2_1.eContents().get(0);
		
		//BComparison:
		//	{BComparison} ref=Reference ("is" bLiteral=BLiteral)?;
		public ParserRule getRule() { return rule; }

		//{BComparison} ref=Reference ("is" bLiteral=BLiteral)?
		public Group getGroup() { return cGroup; }

		//{BComparison}
		public Action getBComparisonAction_0() { return cBComparisonAction_0; }

		//ref=Reference
		public Assignment getRefAssignment_1() { return cRefAssignment_1; }

		//Reference
		public RuleCall getRefReferenceParserRuleCall_1_0() { return cRefReferenceParserRuleCall_1_0; }

		//("is" bLiteral=BLiteral)?
		public Group getGroup_2() { return cGroup_2; }

		//"is"
		public Keyword getIsKeyword_2_0() { return cIsKeyword_2_0; }

		//bLiteral=BLiteral
		public Assignment getBLiteralAssignment_2_1() { return cBLiteralAssignment_2_1; }

		//BLiteral
		public RuleCall getBLiteralBLiteralEnumRuleCall_2_1_0() { return cBLiteralBLiteralEnumRuleCall_2_1_0; }
	}

	public class EnumComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumComparison");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSingleEnumComparisonParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMultiEnumComparisonParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EnumComparison:
		//	SingleEnumComparison | MultiEnumComparison;
		public ParserRule getRule() { return rule; }

		//SingleEnumComparison | MultiEnumComparison
		public Alternatives getAlternatives() { return cAlternatives; }

		//SingleEnumComparison
		public RuleCall getSingleEnumComparisonParserRuleCall_0() { return cSingleEnumComparisonParserRuleCall_0; }

		//MultiEnumComparison
		public RuleCall getMultiEnumComparisonParserRuleCall_1() { return cMultiEnumComparisonParserRuleCall_1; }
	}

	public class SingleEnumComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SingleEnumComparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRefReferenceParserRuleCall_0_0 = (RuleCall)cRefAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cELiteralAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cELiteralEnumLiteralCrossReference_2_0 = (CrossReference)cELiteralAssignment_2.eContents().get(0);
		private final RuleCall cELiteralEnumLiteralIDTerminalRuleCall_2_0_1 = (RuleCall)cELiteralEnumLiteralCrossReference_2_0.eContents().get(1);
		
		//SingleEnumComparison:
		//	ref=Reference "=" eLiteral=[data::EnumLiteral];
		public ParserRule getRule() { return rule; }

		//ref=Reference "=" eLiteral=[data::EnumLiteral]
		public Group getGroup() { return cGroup; }

		//ref=Reference
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }

		//Reference
		public RuleCall getRefReferenceParserRuleCall_0_0() { return cRefReferenceParserRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//eLiteral=[data::EnumLiteral]
		public Assignment getELiteralAssignment_2() { return cELiteralAssignment_2; }

		//[data::EnumLiteral]
		public CrossReference getELiteralEnumLiteralCrossReference_2_0() { return cELiteralEnumLiteralCrossReference_2_0; }

		//ID
		public RuleCall getELiteralEnumLiteralIDTerminalRuleCall_2_0_1() { return cELiteralEnumLiteralIDTerminalRuleCall_2_0_1; }
	}

	public class MultiEnumComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiEnumComparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRefReferenceParserRuleCall_0_0 = (RuleCall)cRefAssignment_0.eContents().get(0);
		private final Assignment cMembershipAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMembershipEnumMembershipEnumRuleCall_1_0 = (RuleCall)cMembershipAssignment_1.eContents().get(0);
		private final Assignment cELiteralsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cELiteralsEnumLiteralsCollectionParserRuleCall_2_0 = (RuleCall)cELiteralsAssignment_2.eContents().get(0);
		
		//MultiEnumComparison:
		//	ref=Reference membership=EnumMembership eLiterals=EnumLiteralsCollection;
		public ParserRule getRule() { return rule; }

		//ref=Reference membership=EnumMembership eLiterals=EnumLiteralsCollection
		public Group getGroup() { return cGroup; }

		//ref=Reference
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }

		//Reference
		public RuleCall getRefReferenceParserRuleCall_0_0() { return cRefReferenceParserRuleCall_0_0; }

		//membership=EnumMembership
		public Assignment getMembershipAssignment_1() { return cMembershipAssignment_1; }

		//EnumMembership
		public RuleCall getMembershipEnumMembershipEnumRuleCall_1_0() { return cMembershipEnumMembershipEnumRuleCall_1_0; }

		//eLiterals=EnumLiteralsCollection
		public Assignment getELiteralsAssignment_2() { return cELiteralsAssignment_2; }

		//EnumLiteralsCollection
		public RuleCall getELiteralsEnumLiteralsCollectionParserRuleCall_2_0() { return cELiteralsEnumLiteralsCollectionParserRuleCall_2_0; }
	}

	public class StringValueComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringValueComparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRefReferenceParserRuleCall_0_0 = (RuleCall)cRefAssignment_0.eContents().get(0);
		private final Keyword cEqualsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTargetValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTargetValueSTRINGTerminalRuleCall_2_0 = (RuleCall)cTargetValueAssignment_2.eContents().get(0);
		
		//StringValueComparison:
		//	ref=Reference "equals" targetValue=STRING;
		public ParserRule getRule() { return rule; }

		//ref=Reference "equals" targetValue=STRING
		public Group getGroup() { return cGroup; }

		//ref=Reference
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }

		//Reference
		public RuleCall getRefReferenceParserRuleCall_0_0() { return cRefReferenceParserRuleCall_0_0; }

		//"equals"
		public Keyword getEqualsKeyword_1() { return cEqualsKeyword_1; }

		//targetValue=STRING
		public Assignment getTargetValueAssignment_2() { return cTargetValueAssignment_2; }

		//STRING
		public RuleCall getTargetValueSTRINGTerminalRuleCall_2_0() { return cTargetValueSTRINGTerminalRuleCall_2_0; }
	}

	public class PresenceCheckElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PresenceCheck");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRefReferenceParserRuleCall_0_0 = (RuleCall)cRefAssignment_0.eContents().get(0);
		private final Keyword cIsPresentKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//PresenceCheck:
		//	ref=Reference "is-present";
		public ParserRule getRule() { return rule; }

		//ref=Reference "is-present"
		public Group getGroup() { return cGroup; }

		//ref=Reference
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }

		//Reference
		public RuleCall getRefReferenceParserRuleCall_0_0() { return cRefReferenceParserRuleCall_0_0; }

		//"is-present"
		public Keyword getIsPresentKeyword_1() { return cIsPresentKeyword_1; }
	}

	public class EnumLiteralsCollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumLiteralsCollection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDirectEnumLiteralsCollectionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnumListReferenceParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EnumLiteralsCollection:
		//	DirectEnumLiteralsCollection | EnumListReference;
		public ParserRule getRule() { return rule; }

		//DirectEnumLiteralsCollection | EnumListReference
		public Alternatives getAlternatives() { return cAlternatives; }

		//DirectEnumLiteralsCollection
		public RuleCall getDirectEnumLiteralsCollectionParserRuleCall_0() { return cDirectEnumLiteralsCollectionParserRuleCall_0; }

		//EnumListReference
		public RuleCall getEnumListReferenceParserRuleCall_1() { return cEnumListReferenceParserRuleCall_1; }
	}

	public class DirectEnumLiteralsCollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DirectEnumLiteralsCollection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDirectEnumLiteralsCollectionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLiteralsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cLiteralsEnumLiteralCrossReference_2_0 = (CrossReference)cLiteralsAssignment_2.eContents().get(0);
		private final RuleCall cLiteralsEnumLiteralIDTerminalRuleCall_2_0_1 = (RuleCall)cLiteralsEnumLiteralCrossReference_2_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//DirectEnumLiteralsCollection: // make sure an object is created even if there are no literals, to trigger the validation on enum type
		//	{DirectEnumLiteralsCollection} "(" literals+=[data::EnumLiteral]* ")";
		public ParserRule getRule() { return rule; }

		//// make sure an object is created even if there are no literals, to trigger the validation on enum type
		//{DirectEnumLiteralsCollection} "(" literals+=[data::EnumLiteral]* ")"
		public Group getGroup() { return cGroup; }

		//// make sure an object is created even if there are no literals, to trigger the validation on enum type
		//{DirectEnumLiteralsCollection}
		public Action getDirectEnumLiteralsCollectionAction_0() { return cDirectEnumLiteralsCollectionAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//literals+=[data::EnumLiteral]*
		public Assignment getLiteralsAssignment_2() { return cLiteralsAssignment_2; }

		//[data::EnumLiteral]
		public CrossReference getLiteralsEnumLiteralCrossReference_2_0() { return cLiteralsEnumLiteralCrossReference_2_0; }

		//ID
		public RuleCall getLiteralsEnumLiteralIDTerminalRuleCall_2_0_1() { return cLiteralsEnumLiteralIDTerminalRuleCall_2_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class EnumListReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumListReference");
		private final Assignment cRefAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cRefEnumListCrossReference_0 = (CrossReference)cRefAssignment.eContents().get(0);
		private final RuleCall cRefEnumListIDTerminalRuleCall_0_1 = (RuleCall)cRefEnumListCrossReference_0.eContents().get(1);
		
		/// * scoping:
		//     * literals must be owned by the data::Enumeration pointed to by the
		//     *  resolution of the (field|alias).path of the containing AtomicReferringBExpression
		//     * validation:
		//     * Empty lists are allowed but flagged with a warning.
		//     * // * scoping:
		//     * ref.enum must equal the data::Enumeration resolved to by (field|alias).path
		//     *  of the containing AtomicReferringBExpression
		//     * /EnumListReference:
		//	ref=[EnumList];
		public ParserRule getRule() { return rule; }

		//ref=[EnumList]
		public Assignment getRefAssignment() { return cRefAssignment; }

		//[EnumList]
		public CrossReference getRefEnumListCrossReference_0() { return cRefEnumListCrossReference_0; }

		//ID
		public RuleCall getRefEnumListIDTerminalRuleCall_0_1() { return cRefEnumListIDTerminalRuleCall_0_1; }
	}
	
	
	public class AttributeClassElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeClass");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cDisplayEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cDisplayDisplayKeyword_0_0 = (Keyword)cDisplayEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cRequiredEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cRequiredRequiredKeyword_1_0 = (Keyword)cRequiredEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cReadonlyEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cReadonlyReadonlyKeyword_2_0 = (Keyword)cReadonlyEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cCalculatedEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cCalculatedCalculatedKeyword_3_0 = (Keyword)cCalculatedEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cDoubleAsteriskEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cDoubleAsteriskDoubleAsteriskKeyword_4_0 = (Keyword)cDoubleAsteriskEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum AttributeClass:
		//	display | required | readonly | calculated | // note: this is a VOA02-specific concept of requiredness
		//	doubleAsterisk;
		public EnumRule getRule() { return rule; }

		//display | required | readonly | calculated | // note: this is a VOA02-specific concept of requiredness
		//doubleAsterisk
		public Alternatives getAlternatives() { return cAlternatives; }

		//display
		public EnumLiteralDeclaration getDisplayEnumLiteralDeclaration_0() { return cDisplayEnumLiteralDeclaration_0; }

		//"display"
		public Keyword getDisplayDisplayKeyword_0_0() { return cDisplayDisplayKeyword_0_0; }

		//required
		public EnumLiteralDeclaration getRequiredEnumLiteralDeclaration_1() { return cRequiredEnumLiteralDeclaration_1; }

		//"required"
		public Keyword getRequiredRequiredKeyword_1_0() { return cRequiredRequiredKeyword_1_0; }

		//readonly
		public EnumLiteralDeclaration getReadonlyEnumLiteralDeclaration_2() { return cReadonlyEnumLiteralDeclaration_2; }

		//"readonly"
		public Keyword getReadonlyReadonlyKeyword_2_0() { return cReadonlyReadonlyKeyword_2_0; }

		//calculated
		public EnumLiteralDeclaration getCalculatedEnumLiteralDeclaration_3() { return cCalculatedEnumLiteralDeclaration_3; }

		//"calculated"
		public Keyword getCalculatedCalculatedKeyword_3_0() { return cCalculatedCalculatedKeyword_3_0; }

		//// note: this is a VOA02-specific concept of requiredness
		//doubleAsterisk
		public EnumLiteralDeclaration getDoubleAsteriskEnumLiteralDeclaration_4() { return cDoubleAsteriskEnumLiteralDeclaration_4; }

		//"doubleAsterisk"
		public Keyword getDoubleAsteriskDoubleAsteriskKeyword_4_0() { return cDoubleAsteriskDoubleAsteriskKeyword_4_0; }
	}

	public class BLiteralElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "BLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTrueEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTrueTrueKeyword_0_0 = (Keyword)cTrueEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cFalseEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cFalseFalseKeyword_1_0 = (Keyword)cFalseEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum BLiteral:
		//	true | false;
		public EnumRule getRule() { return rule; }

		//true | false
		public Alternatives getAlternatives() { return cAlternatives; }

		//true
		public EnumLiteralDeclaration getTrueEnumLiteralDeclaration_0() { return cTrueEnumLiteralDeclaration_0; }

		//"true"
		public Keyword getTrueTrueKeyword_0_0() { return cTrueTrueKeyword_0_0; }

		//false
		public EnumLiteralDeclaration getFalseEnumLiteralDeclaration_1() { return cFalseEnumLiteralDeclaration_1; }

		//"false"
		public Keyword getFalseFalseKeyword_1_0() { return cFalseFalseKeyword_1_0; }
	}

	public class EnumMembershipElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "EnumMembership");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cIsInEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cIsInIsOneOfKeyword_0_0 = (Keyword)cIsInEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cIsNotInEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cIsNotInIsNotOneOfKeyword_1_0 = (Keyword)cIsNotInEnumLiteralDeclaration_1.eContents().get(0);
		
		/// *
		//     * 'true' must be first literal, because that'll be the default value
		//     * which is used when the optional 'is'-part is not present.
		//     * /// enum-related constructs:
		//enum EnumMembership:
		//	isIn="is-one-of" | isNotIn="is-not-one-of";
		public EnumRule getRule() { return rule; }

		//isIn="is-one-of" | isNotIn="is-not-one-of"
		public Alternatives getAlternatives() { return cAlternatives; }

		//isIn="is-one-of"
		public EnumLiteralDeclaration getIsInEnumLiteralDeclaration_0() { return cIsInEnumLiteralDeclaration_0; }

		//"is-one-of"
		public Keyword getIsInIsOneOfKeyword_0_0() { return cIsInIsOneOfKeyword_0_0; }

		//isNotIn="is-not-one-of"
		public EnumLiteralDeclaration getIsNotInEnumLiteralDeclaration_1() { return cIsNotInEnumLiteralDeclaration_1; }

		//"is-not-one-of"
		public Keyword getIsNotInIsNotOneOfKeyword_1_0() { return cIsNotInIsNotOneOfKeyword_1_0; }
	}
	
	private DynamicScreenElements pDynamicScreen;
	private LabelElements pLabel;
	private PathTailElements pPathTail;
	private DeclarationElements pDeclaration;
	private ExternalVariableElements pExternalVariable;
	private EnumListElements pEnumList;
	private DataStoreElements pDataStore;
	private GroupElementElements pGroupElement;
	private FieldElements pField;
	private FieldGroupElements pFieldGroup;
	private AttributeElements pAttribute;
	private EnumFieldAttributeElements pEnumFieldAttribute;
	private NormalAttributeElements pNormalAttribute;
	private AttributeClassExpressionElements pAttributeClassExpression;
	private AttributeClassElements unknownRuleAttributeClass;
	private RestrictionAttributeElements pRestrictionAttribute;
	private RestrictionGroupAttributeElements pRestrictionGroupAttribute;
	private RestrictionRuleElements pRestrictionRule;
	private ReferenceTargetElements pReferenceTarget;
	private ReferenceElements pReference;
	private DummyForExternalVariableElements pDummyForExternalVariable;
	private BExpressionElements pBExpression;
	private BOrExpressionElements pBOrExpression;
	private BAndExpressionElements pBAndExpression;
	private NegationExpressionElements pNegationExpression;
	private TerminalBExpressionElements pTerminalBExpression;
	private AtomicReferringBExpressionElements pAtomicReferringBExpression;
	private BComparisonElements pBComparison;
	private EnumComparisonElements pEnumComparison;
	private SingleEnumComparisonElements pSingleEnumComparison;
	private MultiEnumComparisonElements pMultiEnumComparison;
	private StringValueComparisonElements pStringValueComparison;
	private PresenceCheckElements pPresenceCheck;
	private BLiteralElements unknownRuleBLiteral;
	private EnumMembershipElements unknownRuleEnumMembership;
	private EnumLiteralsCollectionElements pEnumLiteralsCollection;
	private DirectEnumLiteralsCollectionElements pDirectEnumLiteralsCollection;
	private EnumListReferenceElements pEnumListReference;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public DynamicScreenDslGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	/// *
	// * An instance of this DSL describes a screen with a lot of custom
	// * dynamism (and structure) on it. The dynamism supported in the
	// * language are:
	// * 
	// *  - fields are visible, mandatory (required), readonly or not
	// *      depending on the values of other fields
	// *  - selection list (of enums) are restricted depending on the
	// *      values of other fields
	// *
	// * Aspects and features still TODO (roughly in order of priority):
	// *
	// *  1) add paths relative to data stores for non-enum selection lists
	// *  2) short hand for commonly used boolean expressions
	// *  3) sample population of fields (especially useful for data stores @1)
	// * // *
	// * +-----------------------------+
	// * | Infrastructure and generics |
	// * +-----------------------------+
	// * /DynamicScreen:
	//	"dynamic-screen" label=Label "data-import" "=" importURI=STRING "view-class" "=" viewClass=[data::Entity]
	//	declarations+=Declaration* groups+=FieldGroup+;
	public DynamicScreenElements getDynamicScreenAccess() {
		return (pDynamicScreen != null) ? pDynamicScreen : (pDynamicScreen = new DynamicScreenElements());
	}
	
	public ParserRule getDynamicScreenRule() {
		return getDynamicScreenAccess().getRule();
	}

	//Label:
	//	en=STRING ("[nl:" nl=STRING "]")?;
	public LabelElements getLabelAccess() {
		return (pLabel != null) ? pLabel : (pLabel = new LabelElements());
	}
	
	public ParserRule getLabelRule() {
		return getLabelAccess().getRule();
	}

	//PathTail:
	//	"/" field=[data::Field] ("(" asEntity=[data::Entity] ")")? tail=PathTail?;
	public PathTailElements getPathTailAccess() {
		return (pPathTail != null) ? pPathTail : (pPathTail = new PathTailElements());
	}
	
	public ParserRule getPathTailRule() {
		return getPathTailAccess().getRule();
	}

	/// * scoping:
	//     * if asEntity is present, then:
	//     *  1) the type of element must be an entity,
	//     *  2) asEntity must be a proper sub entity of the type of element.
	//     * // *
	//DataStorePathHead:
	//    '[' dataStore=[DataStore] ']' tail=PathTail
	//    ;
	// * // *
	// * +--------------+
	// * | Declarations |
	// * +--------------+
	// * /// TODO  give aliases, enumeration list definitions and conditions their own segment ('aliases:', &c)
	////          as soon as the current format turns out to be unwieldy (saves some filtering as well)
	//Declaration:
	//	ExternalVariable | EnumList | DataStore;
	public DeclarationElements getDeclarationAccess() {
		return (pDeclaration != null) ? pDeclaration : (pDeclaration = new DeclarationElements());
	}
	
	public ParserRule getDeclarationRule() {
		return getDeclarationAccess().getRule();
	}

	//// alias to path inside declared view class
	//// (may only be static and not be present on the screen)
	//ExternalVariable:
	//	"external-var" path=PathTail "as" name=ID;
	public ExternalVariableElements getExternalVariableAccess() {
		return (pExternalVariable != null) ? pExternalVariable : (pExternalVariable = new ExternalVariableElements());
	}
	
	public ParserRule getExternalVariableRule() {
		return getExternalVariableAccess().getRule();
	}

	//EnumList:
	//	"define" name=ID "as" "(" literals+=[data::EnumLiteral]+ ")" "of" ^enum=[data::Enumeration];
	public EnumListElements getEnumListAccess() {
		return (pEnumList != null) ? pEnumList : (pEnumList = new EnumListElements());
	}
	
	public ParserRule getEnumListRule() {
		return getEnumListAccess().getRule();
	}

	/// * scoping:
	//     * all literals must be a member of that resolved data::Enumeration
	//     * /DataStore:
	//	"data-store" name=ID "of-type" class=[data::Entity] multi?="is-multi-valued"?;
	public DataStoreElements getDataStoreAccess() {
		return (pDataStore != null) ? pDataStore : (pDataStore = new DataStoreElements());
	}
	
	public ParserRule getDataStoreRule() {
		return getDataStoreAccess().getRule();
	}

	/// *
	// * +------------------+
	// * | Screen structure |
	// * +------------------+
	// * /GroupElement:
	//	Field | FieldGroup;
	public GroupElementElements getGroupElementAccess() {
		return (pGroupElement != null) ? pGroupElement : (pGroupElement = new GroupElementElements());
	}
	
	public ParserRule getGroupElementRule() {
		return getGroupElementAccess().getRule();
	}

	//Field:
	//	name=ID label=Label path=PathTail attributes+=Attribute*;
	public FieldElements getFieldAccess() {
		return (pField != null) ? pField : (pField = new FieldElements());
	}
	
	public ParserRule getFieldRule() {
		return getFieldAccess().getRule();
	}

	//FieldGroup:
	//	"group" label=Label? ("with" ^with=PathTail)? "{" elements+=GroupElement+ "}" attributes+=Attribute*;
	public FieldGroupElements getFieldGroupAccess() {
		return (pFieldGroup != null) ? pFieldGroup : (pFieldGroup = new FieldGroupElements());
	}
	
	public ParserRule getFieldGroupRule() {
		return getFieldGroupAccess().getRule();
	}

	/// * semantics:
	//     * The paths inside (anywhere) within this group are considered relative
	//     *  to the 'with' path (which itself may be relative to some group instead
	//     *  of the declared view class). Note that the semantics of Field.path
	//     *  also change to be relative.
	//     * The attributes declared at group-level can be overridden at the field-level.
	//     * // * validations:
	//     * For top-level groups, a label is required.
	//     * // *
	// * +------------------+
	// * | Field attributes |
	// * +------------------+
	// * /Attribute:
	//	NormalAttribute | EnumFieldAttribute;
	public AttributeElements getAttributeAccess() {
		return (pAttribute != null) ? pAttribute : (pAttribute = new AttributeElements());
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}

	//EnumFieldAttribute:
	//	RestrictionAttribute | RestrictionGroupAttribute;
	public EnumFieldAttributeElements getEnumFieldAttributeAccess() {
		return (pEnumFieldAttribute != null) ? pEnumFieldAttribute : (pEnumFieldAttribute = new EnumFieldAttributeElements());
	}
	
	public ParserRule getEnumFieldAttributeRule() {
		return getEnumFieldAttributeAccess().getRule();
	}

	//NormalAttribute:
	//	classExpr=AttributeClassExpression ("if" clause=BExpression)?;
	public NormalAttributeElements getNormalAttributeAccess() {
		return (pNormalAttribute != null) ? pNormalAttribute : (pNormalAttribute = new NormalAttributeElements());
	}
	
	public ParserRule getNormalAttributeRule() {
		return getNormalAttributeAccess().getRule();
	}

	/// * semantics:
	//     * 'if' means 'if and only if' (i.e., 'iff').
	//     * /AttributeClassExpression:
	//	classes+=AttributeClass ("+" classes+=AttributeClass)*;
	public AttributeClassExpressionElements getAttributeClassExpressionAccess() {
		return (pAttributeClassExpression != null) ? pAttributeClassExpression : (pAttributeClassExpression = new AttributeClassExpressionElements());
	}
	
	public ParserRule getAttributeClassExpressionRule() {
		return getAttributeClassExpressionAccess().getRule();
	}

	//enum AttributeClass:
	//	display | required | readonly | calculated | // note: this is a VOA02-specific concept of requiredness
	//	doubleAsterisk;
	public AttributeClassElements getAttributeClassAccess() {
		return (unknownRuleAttributeClass != null) ? unknownRuleAttributeClass : (unknownRuleAttributeClass = new AttributeClassElements());
	}
	
	public EnumRule getAttributeClassRule() {
		return getAttributeClassAccess().getRule();
	}

	//RestrictionAttribute:
	//	"restrict-to" literals=EnumLiteralsCollection "if" clause=BExpression;
	public RestrictionAttributeElements getRestrictionAttributeAccess() {
		return (pRestrictionAttribute != null) ? pRestrictionAttribute : (pRestrictionAttribute = new RestrictionAttributeElements());
	}
	
	public ParserRule getRestrictionAttributeRule() {
		return getRestrictionAttributeAccess().getRule();
	}

	/// * validation:
	//     * Can only be used if the (enclosing) field has a data::Enumeration as type.
	//     * scoping:
	//     * The literals must be owned by the Enumeration type of the (enclosing) field.
	//     * semantics:
	//     * If the clause expression evaluates to true, the possible values for the (enclosing)
	//     * Enumeration field should be restricted to the given list.
	//     * TODO  what to do with overlap in the clauses? evaluation in order?
	//     * /RestrictionGroupAttribute: // make sure an object is created even with no rules, to trigger the validation on enum type
	//	{RestrictionGroupAttribute} "restrict-to-group" "<" rules+=RestrictionRule+ ">";
	public RestrictionGroupAttributeElements getRestrictionGroupAttributeAccess() {
		return (pRestrictionGroupAttribute != null) ? pRestrictionGroupAttribute : (pRestrictionGroupAttribute = new RestrictionGroupAttributeElements());
	}
	
	public ParserRule getRestrictionGroupAttributeRule() {
		return getRestrictionGroupAttributeAccess().getRule();
	}

	//RestrictionRule:
	//	literals=EnumLiteralsCollection "if" clause=BExpression;
	public RestrictionRuleElements getRestrictionRuleAccess() {
		return (pRestrictionRule != null) ? pRestrictionRule : (pRestrictionRule = new RestrictionRuleElements());
	}
	
	public ParserRule getRestrictionRuleRule() {
		return getRestrictionRuleAccess().getRule();
	}

	/// * scoping:
	//     * Same as (and already taken of by scoping implementation) for RestrictionAttribute.literals
	//     * // *
	// * +------------+
	// * | References |
	// * +------------+
	// * /ReferenceTarget:
	//	Field | ExternalVariable;
	public ReferenceTargetElements getReferenceTargetAccess() {
		return (pReferenceTarget != null) ? pReferenceTarget : (pReferenceTarget = new ReferenceTargetElements());
	}
	
	public ParserRule getReferenceTargetRule() {
		return getReferenceTargetAccess().getRule();
	}

	//Reference:
	//	ref=[ReferenceTarget];
	public ReferenceElements getReferenceAccess() {
		return (pReference != null) ? pReference : (pReference = new ReferenceElements());
	}
	
	public ParserRule getReferenceRule() {
		return getReferenceAccess().getRule();
	}

	/// *
	// * This dummy type rule is needed because of the 'pull features up' transformation
	// * of the Ecore models generated from Xtext grammars. Without this, the Ecore ends up
	// * with the following elements:
	// *
	// * Declaration: name(ID)
	// * ReferenceTarget: name(ID) (, path)
	// * ExternalVariable -> Declaration, ReferenceTarget
	// *
	// * This would lead to duplicate generation of a field 'ALIAS__NAME' in DynamismDslPackage.
	// * /DummyForExternalVariable:
	//	Declaration | ReferenceTarget;
	public DummyForExternalVariableElements getDummyForExternalVariableAccess() {
		return (pDummyForExternalVariable != null) ? pDummyForExternalVariable : (pDummyForExternalVariable = new DummyForExternalVariableElements());
	}
	
	public ParserRule getDummyForExternalVariableRule() {
		return getDummyForExternalVariableAccess().getRule();
	}

	/// *
	// * +---------------------+
	// * | Boolean expressions |
	// * +---------------------+
	// *
	// * Note: in the following, a solitary 'B' within a camel-cased word
	// * always serves as an abbreviation of 'Boolean'.
	// *
	// * FIXME  grammar ambiguity, due to the fact that operator precedence currently doesn't behave nicely
	// * TODO   rewrite expression grammar to conform with Best Practices (for now: leave as is...)
	// * /// boolean expression tree-building:
	//BExpression:
	//	BOrExpression;
	public BExpressionElements getBExpressionAccess() {
		return (pBExpression != null) ? pBExpression : (pBExpression = new BExpressionElements());
	}
	
	public ParserRule getBExpressionRule() {
		return getBExpressionAccess().getRule();
	}

	//BOrExpression returns BExpression:
	//	BAndExpression ({OrOperation.left=current} ("or" | "|") right=BAndExpression)*;
	public BOrExpressionElements getBOrExpressionAccess() {
		return (pBOrExpression != null) ? pBOrExpression : (pBOrExpression = new BOrExpressionElements());
	}
	
	public ParserRule getBOrExpressionRule() {
		return getBOrExpressionAccess().getRule();
	}

	//BAndExpression returns BExpression:
	//	NegationExpression ({AndOperation.left=current} ("and" | "&") right=NegationExpression)*;
	public BAndExpressionElements getBAndExpressionAccess() {
		return (pBAndExpression != null) ? pBAndExpression : (pBAndExpression = new BAndExpressionElements());
	}
	
	public ParserRule getBAndExpressionRule() {
		return getBAndExpressionAccess().getRule();
	}

	//NegationExpression returns BExpression:
	//	TerminalBExpression | {NegationExpression} ("not" | "!") expr=NegationExpression;
	public NegationExpressionElements getNegationExpressionAccess() {
		return (pNegationExpression != null) ? pNegationExpression : (pNegationExpression = new NegationExpressionElements());
	}
	
	public ParserRule getNegationExpressionRule() {
		return getNegationExpressionAccess().getRule();
	}

	//TerminalBExpression returns BExpression:
	//	AtomicReferringBExpression | "(" BExpression ")";
	public TerminalBExpressionElements getTerminalBExpressionAccess() {
		return (pTerminalBExpression != null) ? pTerminalBExpression : (pTerminalBExpression = new TerminalBExpressionElements());
	}
	
	public ParserRule getTerminalBExpressionRule() {
		return getTerminalBExpressionAccess().getRule();
	}

	//AtomicReferringBExpression:
	//	BComparison | EnumComparison | StringValueComparison | PresenceCheck;
	public AtomicReferringBExpressionElements getAtomicReferringBExpressionAccess() {
		return (pAtomicReferringBExpression != null) ? pAtomicReferringBExpression : (pAtomicReferringBExpression = new AtomicReferringBExpressionElements());
	}
	
	public ParserRule getAtomicReferringBExpressionRule() {
		return getAtomicReferringBExpressionAccess().getRule();
	}

	//BComparison:
	//	{BComparison} ref=Reference ("is" bLiteral=BLiteral)?;
	public BComparisonElements getBComparisonAccess() {
		return (pBComparison != null) ? pBComparison : (pBComparison = new BComparisonElements());
	}
	
	public ParserRule getBComparisonRule() {
		return getBComparisonAccess().getRule();
	}

	//EnumComparison:
	//	SingleEnumComparison | MultiEnumComparison;
	public EnumComparisonElements getEnumComparisonAccess() {
		return (pEnumComparison != null) ? pEnumComparison : (pEnumComparison = new EnumComparisonElements());
	}
	
	public ParserRule getEnumComparisonRule() {
		return getEnumComparisonAccess().getRule();
	}

	//SingleEnumComparison:
	//	ref=Reference "=" eLiteral=[data::EnumLiteral];
	public SingleEnumComparisonElements getSingleEnumComparisonAccess() {
		return (pSingleEnumComparison != null) ? pSingleEnumComparison : (pSingleEnumComparison = new SingleEnumComparisonElements());
	}
	
	public ParserRule getSingleEnumComparisonRule() {
		return getSingleEnumComparisonAccess().getRule();
	}

	//MultiEnumComparison:
	//	ref=Reference membership=EnumMembership eLiterals=EnumLiteralsCollection;
	public MultiEnumComparisonElements getMultiEnumComparisonAccess() {
		return (pMultiEnumComparison != null) ? pMultiEnumComparison : (pMultiEnumComparison = new MultiEnumComparisonElements());
	}
	
	public ParserRule getMultiEnumComparisonRule() {
		return getMultiEnumComparisonAccess().getRule();
	}

	//StringValueComparison:
	//	ref=Reference "equals" targetValue=STRING;
	public StringValueComparisonElements getStringValueComparisonAccess() {
		return (pStringValueComparison != null) ? pStringValueComparison : (pStringValueComparison = new StringValueComparisonElements());
	}
	
	public ParserRule getStringValueComparisonRule() {
		return getStringValueComparisonAccess().getRule();
	}

	//PresenceCheck:
	//	ref=Reference "is-present";
	public PresenceCheckElements getPresenceCheckAccess() {
		return (pPresenceCheck != null) ? pPresenceCheck : (pPresenceCheck = new PresenceCheckElements());
	}
	
	public ParserRule getPresenceCheckRule() {
		return getPresenceCheckAccess().getRule();
	}

	//enum BLiteral:
	//	true | false;
	public BLiteralElements getBLiteralAccess() {
		return (unknownRuleBLiteral != null) ? unknownRuleBLiteral : (unknownRuleBLiteral = new BLiteralElements());
	}
	
	public EnumRule getBLiteralRule() {
		return getBLiteralAccess().getRule();
	}

	/// *
	//     * 'true' must be first literal, because that'll be the default value
	//     * which is used when the optional 'is'-part is not present.
	//     * /// enum-related constructs:
	//enum EnumMembership:
	//	isIn="is-one-of" | isNotIn="is-not-one-of";
	public EnumMembershipElements getEnumMembershipAccess() {
		return (unknownRuleEnumMembership != null) ? unknownRuleEnumMembership : (unknownRuleEnumMembership = new EnumMembershipElements());
	}
	
	public EnumRule getEnumMembershipRule() {
		return getEnumMembershipAccess().getRule();
	}

	//EnumLiteralsCollection:
	//	DirectEnumLiteralsCollection | EnumListReference;
	public EnumLiteralsCollectionElements getEnumLiteralsCollectionAccess() {
		return (pEnumLiteralsCollection != null) ? pEnumLiteralsCollection : (pEnumLiteralsCollection = new EnumLiteralsCollectionElements());
	}
	
	public ParserRule getEnumLiteralsCollectionRule() {
		return getEnumLiteralsCollectionAccess().getRule();
	}

	//DirectEnumLiteralsCollection: // make sure an object is created even if there are no literals, to trigger the validation on enum type
	//	{DirectEnumLiteralsCollection} "(" literals+=[data::EnumLiteral]* ")";
	public DirectEnumLiteralsCollectionElements getDirectEnumLiteralsCollectionAccess() {
		return (pDirectEnumLiteralsCollection != null) ? pDirectEnumLiteralsCollection : (pDirectEnumLiteralsCollection = new DirectEnumLiteralsCollectionElements());
	}
	
	public ParserRule getDirectEnumLiteralsCollectionRule() {
		return getDirectEnumLiteralsCollectionAccess().getRule();
	}

	/// * scoping:
	//     * literals must be owned by the data::Enumeration pointed to by the
	//     *  resolution of the (field|alias).path of the containing AtomicReferringBExpression
	//     * validation:
	//     * Empty lists are allowed but flagged with a warning.
	//     * // * scoping:
	//     * ref.enum must equal the data::Enumeration resolved to by (field|alias).path
	//     *  of the containing AtomicReferringBExpression
	//     * /EnumListReference:
	//	ref=[EnumList];
	public EnumListReferenceElements getEnumListReferenceAccess() {
		return (pEnumListReference != null) ? pEnumListReference : (pEnumListReference = new EnumListReferenceElements());
	}
	
	public ParserRule getEnumListReferenceRule() {
		return getEnumListReferenceAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" | "n" |
	//	"f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
