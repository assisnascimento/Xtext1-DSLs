/*
* generated by Xtext
*/

package nl.dslmeinte.xtext.examples.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class DataModelDslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class DataModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DataModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPrimitivesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPrimitivesPrimitiveTypesParserRuleCall_0_0 = (RuleCall)cPrimitivesAssignment_0.eContents().get(0);
		private final Assignment cCompoundTypesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCompoundTypesCompoundTypeParserRuleCall_1_0 = (RuleCall)cCompoundTypesAssignment_1.eContents().get(0);
		
		/// *
		// * DSL for a textual definition of a data model.
		// *
		// * TODO's:
		// *  1) [must-have] introduce notion of bidirectional associativity/navigability/opposite-ness
		// *  2) [should-have] packaging and modularization across multiple files
		// *  3) [coould-have] importing of primitive types instead of local definition
		// *      -this turns out to be quite difficult because an external
		// *      Ecore type can't be referenced in an alternative rule and
		// *      trying to solve this using a reference construction makes
		// *      the grammar right-recursive...
		// * /DataModel:
		//	primitives=PrimitiveTypes compoundTypes+=CompoundType*;
		public ParserRule getRule() { return rule; }

		//primitives=PrimitiveTypes compoundTypes+=CompoundType*
		public Group getGroup() { return cGroup; }

		//primitives=PrimitiveTypes
		public Assignment getPrimitivesAssignment_0() { return cPrimitivesAssignment_0; }

		//PrimitiveTypes
		public RuleCall getPrimitivesPrimitiveTypesParserRuleCall_0_0() { return cPrimitivesPrimitiveTypesParserRuleCall_0_0; }

		//compoundTypes+=CompoundType*
		public Assignment getCompoundTypesAssignment_1() { return cCompoundTypesAssignment_1; }

		//CompoundType
		public RuleCall getCompoundTypesCompoundTypeParserRuleCall_1_0() { return cCompoundTypesCompoundTypeParserRuleCall_1_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCompoundTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPrimitiveTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// (hierarchical type)
		//Type:
		//	CompoundType | PrimitiveType;
		public ParserRule getRule() { return rule; }

		//CompoundType | PrimitiveType
		public Alternatives getAlternatives() { return cAlternatives; }

		//CompoundType
		public RuleCall getCompoundTypeParserRuleCall_0() { return cCompoundTypeParserRuleCall_0; }

		//PrimitiveType
		public RuleCall getPrimitiveTypeParserRuleCall_1() { return cPrimitiveTypeParserRuleCall_1; }
	}

	public class CompoundTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompoundType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDataTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnumerationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEntityParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//CompoundType:
		//	DataType | Enumeration | Entity;
		public ParserRule getRule() { return rule; }

		//DataType | Enumeration | Entity
		public Alternatives getAlternatives() { return cAlternatives; }

		//DataType
		public RuleCall getDataTypeParserRuleCall_0() { return cDataTypeParserRuleCall_0; }

		//Enumeration
		public RuleCall getEnumerationParserRuleCall_1() { return cEnumerationParserRuleCall_1; }

		//Entity
		public RuleCall getEntityParserRuleCall_2() { return cEntityParserRuleCall_2; }
	}

	public class PrimitiveTypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveTypes");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPrimitiveTypesAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPrimitiveTypesKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPrimitiveTypesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPrimitiveTypesPrimitiveTypeParserRuleCall_3_0 = (RuleCall)cPrimitiveTypesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//PrimitiveTypes:
		//	{PrimitiveTypes} "primitive-types" "{" primitiveTypes+=PrimitiveType* "}";
		public ParserRule getRule() { return rule; }

		//{PrimitiveTypes} "primitive-types" "{" primitiveTypes+=PrimitiveType* "}"
		public Group getGroup() { return cGroup; }

		//{PrimitiveTypes}
		public Action getPrimitiveTypesAction_0() { return cPrimitiveTypesAction_0; }

		//"primitive-types"
		public Keyword getPrimitiveTypesKeyword_1() { return cPrimitiveTypesKeyword_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//primitiveTypes+=PrimitiveType*
		public Assignment getPrimitiveTypesAssignment_3() { return cPrimitiveTypesAssignment_3; }

		//PrimitiveType
		public RuleCall getPrimitiveTypesPrimitiveTypeParserRuleCall_3_0() { return cPrimitiveTypesPrimitiveTypeParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class PrimitiveTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cExtendsKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Assignment cSuperTypeAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final CrossReference cSuperTypePrimitiveTypeCrossReference_1_0_1_0 = (CrossReference)cSuperTypeAssignment_1_0_1.eContents().get(0);
		private final RuleCall cSuperTypePrimitiveTypeIDTerminalRuleCall_1_0_1_0_1 = (RuleCall)cSuperTypePrimitiveTypeCrossReference_1_0_1_0.eContents().get(1);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cRealizationTypeAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cRealizationTypeMetaPrimitiveTypeEnumRuleCall_1_1_1_0 = (RuleCall)cRealizationTypeAssignment_1_1_1.eContents().get(0);
		
		//PrimitiveType:
		//	name=ID ("extends" superType=[PrimitiveType] | ("->" realizationType=MetaPrimitiveType)?);
		public ParserRule getRule() { return rule; }

		//name=ID ("extends" superType=[PrimitiveType] | ("->" realizationType=MetaPrimitiveType)?)
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//"extends" superType=[PrimitiveType] | ("->" realizationType=MetaPrimitiveType)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"extends" superType=[PrimitiveType]
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"extends"
		public Keyword getExtendsKeyword_1_0_0() { return cExtendsKeyword_1_0_0; }

		//superType=[PrimitiveType]
		public Assignment getSuperTypeAssignment_1_0_1() { return cSuperTypeAssignment_1_0_1; }

		//[PrimitiveType]
		public CrossReference getSuperTypePrimitiveTypeCrossReference_1_0_1_0() { return cSuperTypePrimitiveTypeCrossReference_1_0_1_0; }

		//ID
		public RuleCall getSuperTypePrimitiveTypeIDTerminalRuleCall_1_0_1_0_1() { return cSuperTypePrimitiveTypeIDTerminalRuleCall_1_0_1_0_1; }

		//("->" realizationType=MetaPrimitiveType)?
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_1_0() { return cHyphenMinusGreaterThanSignKeyword_1_1_0; }

		//realizationType=MetaPrimitiveType
		public Assignment getRealizationTypeAssignment_1_1_1() { return cRealizationTypeAssignment_1_1_1; }

		//MetaPrimitiveType
		public RuleCall getRealizationTypeMetaPrimitiveTypeEnumRuleCall_1_1_1_0() { return cRealizationTypeMetaPrimitiveTypeEnumRuleCall_1_1_1_0; }
	}

	public class DataTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DataType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDatatypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cFieldsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFieldsFieldParserRuleCall_3_0 = (RuleCall)cFieldsAssignment_3.eContents().get(0);
		private final Assignment cConstraintsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConstraintsConstraintParserRuleCall_4_0 = (RuleCall)cConstraintsAssignment_4.eContents().get(0);
		private final Assignment cFunctionsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFunctionsFunctionParserRuleCall_5_0 = (RuleCall)cFunctionsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//DataType:
		//	"datatype" name=ID "{" fields+=Field* constraints+=Constraint* functions+=Function* "}";
		public ParserRule getRule() { return rule; }

		//"datatype" name=ID "{" fields+=Field* constraints+=Constraint* functions+=Function* "}"
		public Group getGroup() { return cGroup; }

		//"datatype"
		public Keyword getDatatypeKeyword_0() { return cDatatypeKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//fields+=Field*
		public Assignment getFieldsAssignment_3() { return cFieldsAssignment_3; }

		//Field
		public RuleCall getFieldsFieldParserRuleCall_3_0() { return cFieldsFieldParserRuleCall_3_0; }

		//constraints+=Constraint*
		public Assignment getConstraintsAssignment_4() { return cConstraintsAssignment_4; }

		//Constraint
		public RuleCall getConstraintsConstraintParserRuleCall_4_0() { return cConstraintsConstraintParserRuleCall_4_0; }

		//functions+=Function*
		public Assignment getFunctionsAssignment_5() { return cFunctionsAssignment_5; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_5_0() { return cFunctionsFunctionParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class FieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Field");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cModifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cModifierModifierEnumRuleCall_0_0 = (RuleCall)cModifierAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cTypeTypeCrossReference_3_0 = (CrossReference)cTypeAssignment_3.eContents().get(0);
		private final RuleCall cTypeTypeIDTerminalRuleCall_3_0_1 = (RuleCall)cTypeTypeCrossReference_3_0.eContents().get(1);
		
		//Field:
		//	modifier=Modifier? name=ID ":" type=[Type];
		public ParserRule getRule() { return rule; }

		//modifier=Modifier? name=ID ":" type=[Type]
		public Group getGroup() { return cGroup; }

		//modifier=Modifier?
		public Assignment getModifierAssignment_0() { return cModifierAssignment_0; }

		//Modifier
		public RuleCall getModifierModifierEnumRuleCall_0_0() { return cModifierModifierEnumRuleCall_0_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=[Type]
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//[Type]
		public CrossReference getTypeTypeCrossReference_3_0() { return cTypeTypeCrossReference_3_0; }

		//ID
		public RuleCall getTypeTypeIDTerminalRuleCall_3_0_1() { return cTypeTypeIDTerminalRuleCall_3_0_1; }
	}

	public class EnumerationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Enumeration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cLiteralsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLiteralsEnumLiteralParserRuleCall_3_0 = (RuleCall)cLiteralsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Enumeration:
		//	"enum" name=ID "{" literals+=EnumLiteral* "}";
		public ParserRule getRule() { return rule; }

		//"enum" name=ID "{" literals+=EnumLiteral* "}"
		public Group getGroup() { return cGroup; }

		//"enum"
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//literals+=EnumLiteral*
		public Assignment getLiteralsAssignment_3() { return cLiteralsAssignment_3; }

		//EnumLiteral
		public RuleCall getLiteralsEnumLiteralParserRuleCall_3_0() { return cLiteralsEnumLiteralParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class EnumLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumLiteral");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//EnumLiteral:
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class EntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Entity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final UnorderedGroup cUnorderedGroup_0 = (UnorderedGroup)cGroup.eContents().get(0);
		private final Assignment cTransientAssignment_0_0 = (Assignment)cUnorderedGroup_0.eContents().get(0);
		private final Keyword cTransientTransientKeyword_0_0_0 = (Keyword)cTransientAssignment_0_0.eContents().get(0);
		private final Assignment cAbstractAssignment_0_1 = (Assignment)cUnorderedGroup_0.eContents().get(1);
		private final Keyword cAbstractAbstractKeyword_0_1_0 = (Keyword)cAbstractAssignment_0_1.eContents().get(0);
		private final Keyword cEntityKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cExtendsKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cSuperTypeAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cSuperTypeEntityCrossReference_3_1_0 = (CrossReference)cSuperTypeAssignment_3_1.eContents().get(0);
		private final RuleCall cSuperTypeEntityIDTerminalRuleCall_3_1_0_1 = (RuleCall)cSuperTypeEntityCrossReference_3_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cFieldsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFieldsFieldParserRuleCall_5_0 = (RuleCall)cFieldsAssignment_5.eContents().get(0);
		private final Assignment cConstraintsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cConstraintsConstraintParserRuleCall_6_0 = (RuleCall)cConstraintsAssignment_6.eContents().get(0);
		private final Assignment cFunctionsAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cFunctionsFunctionParserRuleCall_7_0 = (RuleCall)cFunctionsAssignment_7.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//Entity:
		//	(transient?="transient"? & abstract?="abstract"?) "entity" name=ID ("extends" superType=[Entity])? // scoping (TODO): can only be an Entity that isn't a sub entity of this entity itself
		//	// TODO  add m2m transformation on Ecore mm to construct eOpposite for Entity.superType
		//	"{" fields+=Field* constraints+=Constraint* functions+=Function* "}";
		public ParserRule getRule() { return rule; }

		//(transient?="transient"? & abstract?="abstract"?) "entity" name=ID ("extends" superType=[Entity])? // scoping (TODO): can only be an Entity that isn't a sub entity of this entity itself
		//// TODO  add m2m transformation on Ecore mm to construct eOpposite for Entity.superType
		//"{" fields+=Field* constraints+=Constraint* functions+=Function* "}"
		public Group getGroup() { return cGroup; }

		//transient?="transient"? & abstract?="abstract"?
		public UnorderedGroup getUnorderedGroup_0() { return cUnorderedGroup_0; }

		//transient?="transient"?
		public Assignment getTransientAssignment_0_0() { return cTransientAssignment_0_0; }

		//"transient"
		public Keyword getTransientTransientKeyword_0_0_0() { return cTransientTransientKeyword_0_0_0; }

		//abstract?="abstract"?
		public Assignment getAbstractAssignment_0_1() { return cAbstractAssignment_0_1; }

		//"abstract"
		public Keyword getAbstractAbstractKeyword_0_1_0() { return cAbstractAbstractKeyword_0_1_0; }

		//"entity"
		public Keyword getEntityKeyword_1() { return cEntityKeyword_1; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//("extends" superType=[Entity])?
		public Group getGroup_3() { return cGroup_3; }

		//"extends"
		public Keyword getExtendsKeyword_3_0() { return cExtendsKeyword_3_0; }

		//superType=[Entity]
		public Assignment getSuperTypeAssignment_3_1() { return cSuperTypeAssignment_3_1; }

		//[Entity]
		public CrossReference getSuperTypeEntityCrossReference_3_1_0() { return cSuperTypeEntityCrossReference_3_1_0; }

		//ID
		public RuleCall getSuperTypeEntityIDTerminalRuleCall_3_1_0_1() { return cSuperTypeEntityIDTerminalRuleCall_3_1_0_1; }

		//// scoping (TODO): can only be an Entity that isn't a sub entity of this entity itself
		//// TODO  add m2m transformation on Ecore mm to construct eOpposite for Entity.superType
		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//fields+=Field*
		public Assignment getFieldsAssignment_5() { return cFieldsAssignment_5; }

		//Field
		public RuleCall getFieldsFieldParserRuleCall_5_0() { return cFieldsFieldParserRuleCall_5_0; }

		//constraints+=Constraint*
		public Assignment getConstraintsAssignment_6() { return cConstraintsAssignment_6; }

		//Constraint
		public RuleCall getConstraintsConstraintParserRuleCall_6_0() { return cConstraintsConstraintParserRuleCall_6_0; }

		//functions+=Function*
		public Assignment getFunctionsAssignment_7() { return cFunctionsAssignment_7; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_7_0() { return cFunctionsFunctionParserRuleCall_7_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_8() { return cRightCurlyBracketKeyword_8; }
	}

	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Constraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstraintKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cUsesKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSlotsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSlotsUsageParserRuleCall_3_0 = (RuleCall)cSlotsAssignment_3.eContents().get(0);
		
		//Constraint:
		//	"constraint" name=ID "uses" slots+=Usage+;
		public ParserRule getRule() { return rule; }

		//"constraint" name=ID "uses" slots+=Usage+
		public Group getGroup() { return cGroup; }

		//"constraint"
		public Keyword getConstraintKeyword_0() { return cConstraintKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"uses"
		public Keyword getUsesKeyword_2() { return cUsesKeyword_2; }

		//slots+=Usage+
		public Assignment getSlotsAssignment_3() { return cSlotsAssignment_3; }

		//Usage
		public RuleCall getSlotsUsageParserRuleCall_3_0() { return cSlotsUsageParserRuleCall_3_0; }
	}

	public class UsageElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Usage");
		private final Assignment cFieldAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cFieldFieldCrossReference_0 = (CrossReference)cFieldAssignment.eContents().get(0);
		private final RuleCall cFieldFieldIDTerminalRuleCall_0_1 = (RuleCall)cFieldFieldCrossReference_0.eContents().get(1);
		
		//// scoping: can only be a field of this compound type
		//Usage:
		//	field=[Field];
		public ParserRule getRule() { return rule; }

		//field=[Field]
		public Assignment getFieldAssignment() { return cFieldAssignment; }

		//[Field]
		public CrossReference getFieldFieldCrossReference_0() { return cFieldFieldCrossReference_0; }

		//ID
		public RuleCall getFieldFieldIDTerminalRuleCall_0_1() { return cFieldFieldIDTerminalRuleCall_0_1; }
	}

	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cReturnTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cReturnTypeTypeCrossReference_3_0 = (CrossReference)cReturnTypeAssignment_3.eContents().get(0);
		private final RuleCall cReturnTypeTypeIDTerminalRuleCall_3_0_1 = (RuleCall)cReturnTypeTypeCrossReference_3_0.eContents().get(1);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cArgumentsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cArgumentsArgumentParserRuleCall_4_1_0 = (RuleCall)cArgumentsAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		//Function:
		//	"function" name=ID ":" returnType=[Type] ("(" arguments+=Argument+ ")")?;
		public ParserRule getRule() { return rule; }

		//"function" name=ID ":" returnType=[Type] ("(" arguments+=Argument+ ")")?
		public Group getGroup() { return cGroup; }

		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//returnType=[Type]
		public Assignment getReturnTypeAssignment_3() { return cReturnTypeAssignment_3; }

		//[Type]
		public CrossReference getReturnTypeTypeCrossReference_3_0() { return cReturnTypeTypeCrossReference_3_0; }

		//ID
		public RuleCall getReturnTypeTypeIDTerminalRuleCall_3_0_1() { return cReturnTypeTypeIDTerminalRuleCall_3_0_1; }

		//("(" arguments+=Argument+ ")")?
		public Group getGroup_4() { return cGroup_4; }

		//"("
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }

		//arguments+=Argument+
		public Assignment getArgumentsAssignment_4_1() { return cArgumentsAssignment_4_1; }

		//Argument
		public RuleCall getArgumentsArgumentParserRuleCall_4_1_0() { return cArgumentsArgumentParserRuleCall_4_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}

	public class ArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Argument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeTypeCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeTypeIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeTypeCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Argument:
		//	type=[Type] name=ID;
		public ParserRule getRule() { return rule; }

		//type=[Type] name=ID
		public Group getGroup() { return cGroup; }

		//type=[Type]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//[Type]
		public CrossReference getTypeTypeCrossReference_0_0() { return cTypeTypeCrossReference_0_0; }

		//ID
		public RuleCall getTypeTypeIDTerminalRuleCall_0_0_1() { return cTypeTypeIDTerminalRuleCall_0_0_1; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}

	public class SimpleTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDataTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPrimitiveTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEnumerationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// convenience super types;
		//SimpleType:
		//	DataType | PrimitiveType | Enumeration;
		public ParserRule getRule() { return rule; }

		//DataType | PrimitiveType | Enumeration
		public Alternatives getAlternatives() { return cAlternatives; }

		//DataType
		public RuleCall getDataTypeParserRuleCall_0() { return cDataTypeParserRuleCall_0; }

		//PrimitiveType
		public RuleCall getPrimitiveTypeParserRuleCall_1() { return cPrimitiveTypeParserRuleCall_1; }

		//Enumeration
		public RuleCall getEnumerationParserRuleCall_2() { return cEnumerationParserRuleCall_2; }
	}

	public class FeatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Feature");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFieldParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunctionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// a Constraint is not considered a feature here
		//Feature:
		//	Field | Function;
		public ParserRule getRule() { return rule; }

		//Field | Function
		public Alternatives getAlternatives() { return cAlternatives; }

		//Field
		public RuleCall getFieldParserRuleCall_0() { return cFieldParserRuleCall_0; }

		//Function
		public RuleCall getFunctionParserRuleCall_1() { return cFunctionParserRuleCall_1; }
	}
	
	
	public class MetaPrimitiveTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "MetaPrimitiveType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cStringEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cStringStringKeyword_0_0 = (Keyword)cStringEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cIntEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cIntIntKeyword_1_0 = (Keyword)cIntEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cNumberEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cNumberNumberKeyword_2_0 = (Keyword)cNumberEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cBooleanEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cBooleanBooleanKeyword_3_0 = (Keyword)cBooleanEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum MetaPrimitiveType:
		//	string | int | number | boolean;
		public EnumRule getRule() { return rule; }

		//string | int | number | boolean
		public Alternatives getAlternatives() { return cAlternatives; }

		//string
		public EnumLiteralDeclaration getStringEnumLiteralDeclaration_0() { return cStringEnumLiteralDeclaration_0; }

		//"string"
		public Keyword getStringStringKeyword_0_0() { return cStringStringKeyword_0_0; }

		//int
		public EnumLiteralDeclaration getIntEnumLiteralDeclaration_1() { return cIntEnumLiteralDeclaration_1; }

		//"int"
		public Keyword getIntIntKeyword_1_0() { return cIntIntKeyword_1_0; }

		//number
		public EnumLiteralDeclaration getNumberEnumLiteralDeclaration_2() { return cNumberEnumLiteralDeclaration_2; }

		//"number"
		public Keyword getNumberNumberKeyword_2_0() { return cNumberNumberKeyword_2_0; }

		//boolean
		public EnumLiteralDeclaration getBooleanEnumLiteralDeclaration_3() { return cBooleanEnumLiteralDeclaration_3; }

		//"boolean"
		public Keyword getBooleanBooleanKeyword_3_0() { return cBooleanBooleanKeyword_3_0; }
	}

	public class ModifierElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Modifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cOptionalEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cOptionalOptionalKeyword_0_0 = (Keyword)cOptionalEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cRequiredEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cRequiredRequiredKeyword_1_0 = (Keyword)cRequiredEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cRepeatedEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cRepeatedRepeatedKeyword_2_0 = (Keyword)cRepeatedEnumLiteralDeclaration_2.eContents().get(0);
		
		/// *
		//     * validation: if type refers to a PrimitiveType, then modifier != repeated
		//     * scoping: if the Field resides inside a DataType, then type must be a PrimitiveType;
		//     * 
		//     * Note that this definition might seem a bit contrived, but that's
		//     * because from a parsing viewpoint splitting this definition up
		//     * (into a SimpleField and ComplexField, e.g.) causes the grammar
		//     * to be ambiguous.
		//     * /enum Modifier:
		//	optional | required | repeated;
		public EnumRule getRule() { return rule; }

		//optional | required | repeated
		public Alternatives getAlternatives() { return cAlternatives; }

		//optional
		public EnumLiteralDeclaration getOptionalEnumLiteralDeclaration_0() { return cOptionalEnumLiteralDeclaration_0; }

		//"optional"
		public Keyword getOptionalOptionalKeyword_0_0() { return cOptionalOptionalKeyword_0_0; }

		//required
		public EnumLiteralDeclaration getRequiredEnumLiteralDeclaration_1() { return cRequiredEnumLiteralDeclaration_1; }

		//"required"
		public Keyword getRequiredRequiredKeyword_1_0() { return cRequiredRequiredKeyword_1_0; }

		//repeated
		public EnumLiteralDeclaration getRepeatedEnumLiteralDeclaration_2() { return cRepeatedEnumLiteralDeclaration_2; }

		//"repeated"
		public Keyword getRepeatedRepeatedKeyword_2_0() { return cRepeatedRepeatedKeyword_2_0; }
	}
	
	private DataModelElements pDataModel;
	private TypeElements pType;
	private CompoundTypeElements pCompoundType;
	private PrimitiveTypesElements pPrimitiveTypes;
	private MetaPrimitiveTypeElements unknownRuleMetaPrimitiveType;
	private PrimitiveTypeElements pPrimitiveType;
	private DataTypeElements pDataType;
	private FieldElements pField;
	private ModifierElements unknownRuleModifier;
	private EnumerationElements pEnumeration;
	private EnumLiteralElements pEnumLiteral;
	private EntityElements pEntity;
	private ConstraintElements pConstraint;
	private UsageElements pUsage;
	private FunctionElements pFunction;
	private ArgumentElements pArgument;
	private SimpleTypeElements pSimpleType;
	private FeatureElements pFeature;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public DataModelDslGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	/// *
	// * DSL for a textual definition of a data model.
	// *
	// * TODO's:
	// *  1) [must-have] introduce notion of bidirectional associativity/navigability/opposite-ness
	// *  2) [should-have] packaging and modularization across multiple files
	// *  3) [coould-have] importing of primitive types instead of local definition
	// *      -this turns out to be quite difficult because an external
	// *      Ecore type can't be referenced in an alternative rule and
	// *      trying to solve this using a reference construction makes
	// *      the grammar right-recursive...
	// * /DataModel:
	//	primitives=PrimitiveTypes compoundTypes+=CompoundType*;
	public DataModelElements getDataModelAccess() {
		return (pDataModel != null) ? pDataModel : (pDataModel = new DataModelElements());
	}
	
	public ParserRule getDataModelRule() {
		return getDataModelAccess().getRule();
	}

	//// (hierarchical type)
	//Type:
	//	CompoundType | PrimitiveType;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//CompoundType:
	//	DataType | Enumeration | Entity;
	public CompoundTypeElements getCompoundTypeAccess() {
		return (pCompoundType != null) ? pCompoundType : (pCompoundType = new CompoundTypeElements());
	}
	
	public ParserRule getCompoundTypeRule() {
		return getCompoundTypeAccess().getRule();
	}

	//PrimitiveTypes:
	//	{PrimitiveTypes} "primitive-types" "{" primitiveTypes+=PrimitiveType* "}";
	public PrimitiveTypesElements getPrimitiveTypesAccess() {
		return (pPrimitiveTypes != null) ? pPrimitiveTypes : (pPrimitiveTypes = new PrimitiveTypesElements());
	}
	
	public ParserRule getPrimitiveTypesRule() {
		return getPrimitiveTypesAccess().getRule();
	}

	//enum MetaPrimitiveType:
	//	string | int | number | boolean;
	public MetaPrimitiveTypeElements getMetaPrimitiveTypeAccess() {
		return (unknownRuleMetaPrimitiveType != null) ? unknownRuleMetaPrimitiveType : (unknownRuleMetaPrimitiveType = new MetaPrimitiveTypeElements());
	}
	
	public EnumRule getMetaPrimitiveTypeRule() {
		return getMetaPrimitiveTypeAccess().getRule();
	}

	//PrimitiveType:
	//	name=ID ("extends" superType=[PrimitiveType] | ("->" realizationType=MetaPrimitiveType)?);
	public PrimitiveTypeElements getPrimitiveTypeAccess() {
		return (pPrimitiveType != null) ? pPrimitiveType : (pPrimitiveType = new PrimitiveTypeElements());
	}
	
	public ParserRule getPrimitiveTypeRule() {
		return getPrimitiveTypeAccess().getRule();
	}

	//DataType:
	//	"datatype" name=ID "{" fields+=Field* constraints+=Constraint* functions+=Function* "}";
	public DataTypeElements getDataTypeAccess() {
		return (pDataType != null) ? pDataType : (pDataType = new DataTypeElements());
	}
	
	public ParserRule getDataTypeRule() {
		return getDataTypeAccess().getRule();
	}

	//Field:
	//	modifier=Modifier? name=ID ":" type=[Type];
	public FieldElements getFieldAccess() {
		return (pField != null) ? pField : (pField = new FieldElements());
	}
	
	public ParserRule getFieldRule() {
		return getFieldAccess().getRule();
	}

	/// *
	//     * validation: if type refers to a PrimitiveType, then modifier != repeated
	//     * scoping: if the Field resides inside a DataType, then type must be a PrimitiveType;
	//     * 
	//     * Note that this definition might seem a bit contrived, but that's
	//     * because from a parsing viewpoint splitting this definition up
	//     * (into a SimpleField and ComplexField, e.g.) causes the grammar
	//     * to be ambiguous.
	//     * /enum Modifier:
	//	optional | required | repeated;
	public ModifierElements getModifierAccess() {
		return (unknownRuleModifier != null) ? unknownRuleModifier : (unknownRuleModifier = new ModifierElements());
	}
	
	public EnumRule getModifierRule() {
		return getModifierAccess().getRule();
	}

	//Enumeration:
	//	"enum" name=ID "{" literals+=EnumLiteral* "}";
	public EnumerationElements getEnumerationAccess() {
		return (pEnumeration != null) ? pEnumeration : (pEnumeration = new EnumerationElements());
	}
	
	public ParserRule getEnumerationRule() {
		return getEnumerationAccess().getRule();
	}

	//EnumLiteral:
	//	name=ID;
	public EnumLiteralElements getEnumLiteralAccess() {
		return (pEnumLiteral != null) ? pEnumLiteral : (pEnumLiteral = new EnumLiteralElements());
	}
	
	public ParserRule getEnumLiteralRule() {
		return getEnumLiteralAccess().getRule();
	}

	//Entity:
	//	(transient?="transient"? & abstract?="abstract"?) "entity" name=ID ("extends" superType=[Entity])? // scoping (TODO): can only be an Entity that isn't a sub entity of this entity itself
	//	// TODO  add m2m transformation on Ecore mm to construct eOpposite for Entity.superType
	//	"{" fields+=Field* constraints+=Constraint* functions+=Function* "}";
	public EntityElements getEntityAccess() {
		return (pEntity != null) ? pEntity : (pEntity = new EntityElements());
	}
	
	public ParserRule getEntityRule() {
		return getEntityAccess().getRule();
	}

	//Constraint:
	//	"constraint" name=ID "uses" slots+=Usage+;
	public ConstraintElements getConstraintAccess() {
		return (pConstraint != null) ? pConstraint : (pConstraint = new ConstraintElements());
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}

	//// scoping: can only be a field of this compound type
	//Usage:
	//	field=[Field];
	public UsageElements getUsageAccess() {
		return (pUsage != null) ? pUsage : (pUsage = new UsageElements());
	}
	
	public ParserRule getUsageRule() {
		return getUsageAccess().getRule();
	}

	//Function:
	//	"function" name=ID ":" returnType=[Type] ("(" arguments+=Argument+ ")")?;
	public FunctionElements getFunctionAccess() {
		return (pFunction != null) ? pFunction : (pFunction = new FunctionElements());
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}

	//Argument:
	//	type=[Type] name=ID;
	public ArgumentElements getArgumentAccess() {
		return (pArgument != null) ? pArgument : (pArgument = new ArgumentElements());
	}
	
	public ParserRule getArgumentRule() {
		return getArgumentAccess().getRule();
	}

	//// convenience super types;
	//SimpleType:
	//	DataType | PrimitiveType | Enumeration;
	public SimpleTypeElements getSimpleTypeAccess() {
		return (pSimpleType != null) ? pSimpleType : (pSimpleType = new SimpleTypeElements());
	}
	
	public ParserRule getSimpleTypeRule() {
		return getSimpleTypeAccess().getRule();
	}

	//// a Constraint is not considered a feature here
	//Feature:
	//	Field | Function;
	public FeatureElements getFeatureAccess() {
		return (pFeature != null) ? pFeature : (pFeature = new FeatureElements());
	}
	
	public ParserRule getFeatureRule() {
		return getFeatureAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" | "n" |
	//	"f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
