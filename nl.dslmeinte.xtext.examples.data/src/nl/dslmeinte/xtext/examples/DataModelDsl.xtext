grammar nl.dslmeinte.xtext.examples.DataModelDsl with org.eclipse.xtext.common.Terminals

generate dataModelDsl "http://www.dslmeinte.nl/xtext/examples/DataModelDsl"


/*
 * DSL for a textual definition of a data model which is slightly less
 * aenemic than usual. The prime client for this DSL is the dynamic screen
 * DSL.
 *
 * TODO's:
 *  1) [must-have] introduce notion of containment
 *  2) [must-have] bidirectional associativity/navigability/opposite-ness
 *  3) [should-have] packaging and modularization across multiple files
 *  4) [coould-have] importing of primitive types instead of local definition
 */


/**
 * The root model element, comprised of one primitive types section
 * and the definition of any number of compound types.
 */
DataModel:
    primitives=PrimitiveTypes
    ( compoundTypes += CompoundType )*
    ;

/**
 * Convenience meta type
 * (not actually referenced from anywhere in the grammar def.).
 */
Type:
    CompoundType | PrimitiveType
    ;

CompoundType:
    DataType | Enumeration | Entity
    ;

/**
 * A block of primitive type definitions.
 */
PrimitiveTypes:
    {PrimitiveTypes}
    'primitive-types'
    '{'
        ( primitiveTypes += PrimitiveType )*
    '}'
    ;

enum MetaPrimitiveType:
    string | int | number | boolean
    ;

/**
 * Definition for a primitive type which has a name and
 * either has a realization type (to connect it with e.g. Java primitive types)
 * or extends an existing primitive type -in which case the realization type is
 * that of the super type.
 */
PrimitiveType:
    name=ID
        (
            ( 'extends' superType=[PrimitiveType] )
          |
            ( '->' realizationType=MetaPrimitiveType )?
        )
    ;

/**
 * Definition of a data type complete with its constituent fields,
 * constraints and function.
 */
DataType:
    'datatype' name=ID
    '{'
        ( fields += Field )*
        ( constraints += Constraint )*
        ( functions += Function )*
    '}'
    ;

Field :
    ( modifier=Modifier )? name=ID ':' type=[Type]
    ;
    /*
     * validation: if type refers to a PrimitiveType, then modifier != repeated
     * scoping: if the Field resides inside a DataType, then type must be a PrimitiveType;
     * 
     * Note that this definition might seem a bit contrived, but that's
     * because, from a parsing viewpoint, splitting this definition up
     * (into a SimpleField and ComplexField, e.g.) causes the grammar
     * to be ambiguous.
     */

enum Modifier:
    optional | required | repeated
    ;

Enumeration:
    'enum' name=ID
    '{'
        ( literals += EnumLiteral )*
    '}'
    ;

EnumLiteral:
    name=ID
    ;

Entity:
    ( transient?='transient'? & abstract?='abstract'? ) 'entity' name=ID
        ( 'extends' superType=[Entity] )?
            // scoping (TODO): can only be an Entity that isn't a sub entity of this entity itself
            // TODO  add m2m transformation on Ecore mm to construct eOpposite for Entity.superType
    '{'
        ( fields += Field )*
        ( constraints += Constraint )*
        ( functions += Function )*
    '}'
    ;

Constraint:
    'constraint' name=ID 'uses' ( slots += Usage )+
    ;

Usage:
    field=[Field]
        // scoping: can only be a field of this compound type
    ;

Function:
    'function' name=ID ':' returnType=[Type]
        (
            '('
                ( arguments += Argument )+
            ')'
        )?
    ;

Argument:
    type=[Type] name=ID
    ;


// convenience super types;
SimpleType:
    DataType | PrimitiveType | Enumeration
    ;

Feature:    // a Constraint is not considered a feature here
    Field | Function
    ;

